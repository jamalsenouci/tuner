<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#0a0a0a">
  <title>Tuner</title>
  <link rel="manifest" href="manifest.json">
  <link rel="icon" href="icon.svg" type="image/svg+xml">
  <link rel="apple-touch-icon" href="icon.svg">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=DM+Mono:wght@300;400;500&family=Instrument+Serif:ital@0;1&display=swap');

    :root {
      --bg-deep: #0a0a0a;
      --bg-surface: #141414;
      --amber: #d4a853;
      --amber-glow: rgba(212, 168, 83, 0.4);
      --amber-dim: rgba(212, 168, 83, 0.15);
      --text-primary: #e8e4dc;
      --text-muted: rgba(232, 228, 220, 0.4);

      /* Tuning accuracy colors */
      --tune-color: #d4a853;
      --tune-glow: rgba(212, 168, 83, 0.4);

      --color-perfect: #4ade80;
      --color-close: #a3e635;
      --color-medium: #facc15;
      --color-far: #f97316;
      --color-very-far: #ef4444;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    html, body {
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: 'DM Mono', monospace;
      background: var(--bg-deep);
      color: var(--text-primary);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      min-height: 100dvh;
      padding: env(safe-area-inset-top) 24px calc(env(safe-area-inset-bottom) + 64px);
      user-select: none;
      -webkit-user-select: none;
    }

    /* Subtle grain texture */
    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
      opacity: 0.03;
      pointer-events: none;
      z-index: 100;
    }

    .header {
      text-align: center;
      padding-top: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
    }

    .logo {
      font-family: 'Instrument Serif', serif;
      font-size: 14px;
      font-weight: 400;
      letter-spacing: 0.3em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .mode-toggle {
      position: absolute;
      left: 24px;
      top: calc(env(safe-area-inset-top) + 64px);
      width: 36px;
      height: 36px;
      border: none;
      background: var(--bg-surface);
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      border: 1px solid rgba(232, 228, 220, 0.1);
    }

    .mode-toggle:active {
      transform: scale(0.92);
    }

    .mode-toggle svg {
      width: 18px;
      height: 18px;
      fill: var(--text-muted);
      transition: fill 0.2s ease;
    }

    .mode-toggle.strobe-active svg {
      fill: var(--amber);
    }

    .mode-toggle.strobe-active {
      border-color: rgba(212, 168, 83, 0.3);
    }

    .sound-toggle {
      position: absolute;
      right: 24px;
      top: calc(env(safe-area-inset-top) + 20px);
      width: 36px;
      height: 36px;
      border: none;
      background: var(--bg-surface);
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      border: 1px solid rgba(232, 228, 220, 0.1);
    }

    .sound-toggle:active {
      transform: scale(0.92);
    }

    .sound-toggle svg {
      width: 18px;
      height: 18px;
      fill: var(--text-muted);
      transition: fill 0.2s ease;
    }

    .sound-toggle.enabled svg {
      fill: var(--amber);
    }

    .sound-toggle.enabled {
      border-color: rgba(212, 168, 83, 0.3);
    }

    .tuner-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      max-width: 340px;
    }

    .note-display {
      text-align: center;
      margin-bottom: 48px;
    }

    .current-note {
      font-family: 'Instrument Serif', serif;
      font-size: 120px;
      font-weight: 400;
      line-height: 1;
      color: var(--tune-color);
      transition: color 0.2s ease, text-shadow 0.2s ease;
      text-shadow: 0 0 40px var(--tune-glow);
    }

    .current-octave {
      font-size: 32px;
      font-weight: 300;
      color: var(--text-muted);
      vertical-align: super;
      margin-left: 4px;
    }

    .frequency {
      font-size: 13px;
      font-weight: 300;
      color: var(--text-muted);
      letter-spacing: 0.15em;
      margin-top: 12px;
    }

    /* Meter */
    .meter {
      position: relative;
      width: 100%;
      height: 140px;
      margin-bottom: 48px;
    }

    .meter-arc {
      position: relative;
      width: 100%;
      height: 100%;
    }

    .meter-svg {
      width: 100%;
      height: 100%;
      overflow: visible;
    }

    .meter-track {
      fill: none;
      stroke: var(--bg-surface);
      stroke-width: 2;
    }

    .meter-ticks line {
      stroke: var(--text-muted);
      stroke-width: 1;
    }

    .meter-ticks .center-tick {
      stroke: var(--amber);
      stroke-width: 2;
    }

    .meter-labels text {
      font-family: 'DM Mono', monospace;
      font-size: 10px;
      fill: var(--text-muted);
    }

    .meter-labels .center-label {
      fill: var(--amber);
    }

    /* Strobe */
    .strobe-container {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      border-radius: 12px;
    }

    .strobe-container.active {
      display: flex;
    }

    .strobe-canvas {
      width: 100%;
      height: 100%;
      border-radius: 12px;
    }

    .meter.strobe-mode .needle-container {
      display: none;
    }

    .meter.strobe-mode .meter-svg {
      opacity: 0;
    }

    .meter.strobe-mode .strobe-container {
      display: flex;
    }

    .strobe-hint {
      display: none;
      font-size: 11px;
      font-weight: 300;
      color: var(--text-muted);
      text-align: center;
      letter-spacing: 0.05em;
      line-height: 1.5;
      margin-top: 8px;
    }

    .meter.strobe-mode ~ .strobe-hint {
      display: block;
    }

    /* Needle */
    .needle-container {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform-origin: bottom center;
    }

    .needle {
      width: 2px;
      height: 110px;
      background: linear-gradient(to top, var(--tune-color), var(--tune-color) 80%, transparent);
      border-radius: 1px;
      transform: translateX(-50%);
      box-shadow: 0 0 12px var(--tune-glow);
      transition: background 0.2s ease, box-shadow 0.2s ease;
    }

    .needle-tip {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 8px;
      height: 8px;
      background: var(--tune-color);
      border-radius: 50%;
      box-shadow: 0 0 20px var(--tune-glow);
      transition: background 0.2s ease, box-shadow 0.2s ease;
    }

    .needle-base {
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      width: 16px;
      height: 16px;
      background: var(--bg-surface);
      border: 2px solid var(--tune-glow);
      border-radius: 50%;
      transition: border-color 0.2s ease;
    }

    /* Cents display */
    .cents-display {
      font-size: 14px;
      font-weight: 400;
      color: var(--text-muted);
      letter-spacing: 0.1em;
      text-align: center;
      min-width: 80px;
    }

    .cents-value {
      color: var(--tune-color);
      transition: color 0.2s ease;
    }

    /* String buttons */
    .strings-container {
      width: 100%;
      max-width: 320px;
    }

    .tuning-selector {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin-bottom: 16px;
      cursor: pointer;
      padding: 8px 16px;
      border-radius: 20px;
      transition: background 0.2s ease;
    }

    .tuning-selector:active {
      background: rgba(232, 228, 220, 0.05);
    }

    .tuning-name {
      font-size: 11px;
      font-weight: 400;
      color: var(--text-muted);
      letter-spacing: 0.15em;
      text-transform: uppercase;
    }

    .tuning-arrow {
      width: 0;
      height: 0;
      border-left: 4px solid transparent;
      border-right: 4px solid transparent;
      border-top: 5px solid var(--text-muted);
      transition: transform 0.2s ease;
    }

    .tuning-selector.open .tuning-arrow {
      transform: rotate(180deg);
    }

    /* Tuning modal */
    .tuning-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      z-index: 200;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
    }

    .tuning-modal.open {
      opacity: 1;
      pointer-events: auto;
    }

    .tuning-modal-content {
      width: 100%;
      max-width: 400px;
      max-height: 70vh;
      background: var(--bg-surface);
      border-radius: 20px 20px 0 0;
      padding: 24px 0 calc(env(safe-area-inset-bottom) + 24px);
      transform: translateY(100%);
      transition: transform 0.3s cubic-bezier(0.32, 0.72, 0, 1);
      overflow-y: auto;
    }

    .tuning-modal.open .tuning-modal-content {
      transform: translateY(0);
    }

    .tuning-modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 24px 16px;
      border-bottom: 1px solid rgba(232, 228, 220, 0.06);
    }

    .tuning-modal-title {
      font-family: 'Instrument Serif', serif;
      font-size: 18px;
      color: var(--text-primary);
    }

    .tuning-modal-close {
      width: 32px;
      height: 32px;
      border: none;
      background: rgba(232, 228, 220, 0.1);
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-muted);
      font-size: 18px;
    }

    .tuning-category {
      padding: 16px 24px 8px;
    }

    .tuning-category-label {
      font-size: 10px;
      font-weight: 500;
      color: var(--text-muted);
      letter-spacing: 0.15em;
      text-transform: uppercase;
    }

    .tuning-option {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 24px;
      cursor: pointer;
      transition: background 0.15s ease;
      border: none;
      background: transparent;
      width: 100%;
      text-align: left;
    }

    .tuning-option:active {
      background: rgba(212, 168, 83, 0.1);
    }

    .tuning-option.active {
      background: rgba(212, 168, 83, 0.08);
    }

    .tuning-option-name {
      font-size: 15px;
      color: var(--text-primary);
    }

    .tuning-option.active .tuning-option-name {
      color: var(--amber);
    }

    .tuning-option-notes {
      font-size: 12px;
      font-weight: 300;
      color: var(--text-muted);
      letter-spacing: 0.1em;
    }

    .strings {
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }

    .string-btn {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 16px 8px;
      background: var(--bg-surface);
      border: 1px solid rgba(232, 228, 220, 0.06);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .string-btn:active {
      transform: scale(0.96);
      background: rgba(212, 168, 83, 0.1);
    }

    .string-btn.active {
      border-color: var(--amber);
      background: rgba(212, 168, 83, 0.08);
    }

    .string-btn.auto-detected {
      border-color: var(--tune-color);
      background: rgba(212, 168, 83, 0.06);
    }

    .string-btn.auto-detected .string-note {
      color: var(--tune-color);
      transition: color 0.2s ease;
    }

    .string-note {
      font-family: 'Instrument Serif', serif;
      font-size: 24px;
      color: var(--text-primary);
    }

    .string-number {
      font-size: 10px;
      font-weight: 300;
      color: var(--text-muted);
      margin-top: 4px;
    }

    /* Start button */
    .start-container {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--bg-deep);
      z-index: 50;
      transition: opacity 0.4s ease;
    }

    .start-container.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .start-btn {
      width: 140px;
      height: 140px;
      border-radius: 50%;
      background: var(--bg-surface);
      border: 1px solid rgba(212, 168, 83, 0.2);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      box-shadow: 0 0 0 0 var(--amber-dim);
    }

    .start-btn:active {
      transform: scale(0.95);
    }

    .start-btn:hover {
      border-color: var(--amber);
      box-shadow: 0 0 40px var(--amber-dim);
    }

    .start-icon {
      width: 32px;
      height: 32px;
      border: 2px solid var(--amber);
      border-radius: 50%;
      position: relative;
    }

    .start-icon::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 8px;
      height: 8px;
      background: var(--amber);
      border-radius: 50%;
    }

    .start-text {
      font-size: 11px;
      font-weight: 400;
      color: var(--text-muted);
      letter-spacing: 0.2em;
      text-transform: uppercase;
      margin-top: 24px;
    }

    /* Listening animation */
    @keyframes pulse {
      0%, 100% { opacity: 0.4; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.05); }
    }

    .listening .start-icon {
      animation: pulse 1.5s ease-in-out infinite;
    }

    /* No signal state */
    .no-signal .current-note {
      color: var(--text-muted);
    }

    .no-signal .needle-container {
      opacity: 0.3;
    }

    /* Input level meter */
    .level-meter {
      width: 100%;
      max-width: 340px;
      height: 4px;
      background: var(--bg-surface);
      border-radius: 2px;
      overflow: hidden;
      margin-top: 8px;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .level-meter.active {
      opacity: 1;
    }

    .level-meter-fill {
      height: 100%;
      width: 0%;
      border-radius: 2px;
      background: var(--amber);
      transition: width 0.08s linear, background 0.2s ease;
    }

    .level-meter-fill.hot {
      background: #f97316;
    }

    .level-meter-fill.clip {
      background: #ef4444;
    }

    /* Tab bar */
    .tab-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      display: flex;
      background: var(--bg-surface);
      border-top: 1px solid rgba(232, 228, 220, 0.06);
      padding-bottom: env(safe-area-inset-bottom);
      z-index: 90;
    }

    .tab-bar-btn {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      padding: 10px 0;
      border: none;
      background: transparent;
      cursor: pointer;
      transition: color 0.2s ease;
    }

    .tab-bar-btn svg {
      width: 22px;
      height: 22px;
      fill: var(--text-muted);
      transition: fill 0.2s ease;
    }

    .tab-bar-btn span {
      font-family: 'DM Mono', monospace;
      font-size: 10px;
      color: var(--text-muted);
      letter-spacing: 0.1em;
      transition: color 0.2s ease;
    }

    .tab-bar-btn.active svg {
      fill: var(--amber);
    }

    .tab-bar-btn.active span {
      color: var(--amber);
    }

    /* View visibility */
    .tuner-view-wrapper {
      display: contents;
    }

    .tuner-view-wrapper.hidden,
    .tuner-view-wrapper.hidden ~ .strings-container {
      display: none;
    }

    /* Metronome */
    .metronome-container {
      flex: 1;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      max-width: 340px;
      gap: 32px;
    }

    .metronome-container.active {
      display: flex;
    }

    .bpm-display {
      text-align: center;
    }

    .bpm-value {
      font-family: 'Instrument Serif', serif;
      font-size: 96px;
      font-weight: 400;
      line-height: 1;
      color: var(--amber);
      text-shadow: 0 0 40px var(--amber-glow);
    }

    .bpm-label {
      font-size: 13px;
      font-weight: 300;
      color: var(--text-muted);
      letter-spacing: 0.15em;
      margin-top: 8px;
    }

    .bpm-controls {
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .bpm-btn {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: var(--bg-surface);
      border: 1px solid rgba(232, 228, 220, 0.1);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'DM Mono', monospace;
      font-size: 20px;
      color: var(--text-primary);
      transition: all 0.15s ease;
    }

    .bpm-btn:active {
      transform: scale(0.92);
      background: rgba(212, 168, 83, 0.1);
      border-color: var(--amber);
    }

    .beat-indicators {
      display: flex;
      gap: 16px;
    }

    .beat-dot {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--bg-surface);
      border: 1px solid rgba(232, 228, 220, 0.15);
      transition: all 0.1s ease;
    }

    .beat-dot.accent {
      border-color: rgba(212, 168, 83, 0.3);
    }

    .beat-dot.active {
      background: var(--amber);
      border-color: var(--amber);
      box-shadow: 0 0 16px var(--amber-glow);
    }

    .metronome-play {
      width: 72px;
      height: 72px;
      border-radius: 50%;
      background: var(--bg-surface);
      border: 2px solid rgba(212, 168, 83, 0.3);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .metronome-play:active {
      transform: scale(0.95);
    }

    .metronome-play.playing {
      border-color: var(--amber);
      box-shadow: 0 0 30px var(--amber-dim);
    }

    .metronome-play svg {
      width: 28px;
      height: 28px;
      fill: var(--amber);
    }

    .tap-tempo {
      padding: 12px 28px;
      border-radius: 24px;
      background: var(--bg-surface);
      border: 1px solid rgba(232, 228, 220, 0.1);
      cursor: pointer;
      font-family: 'DM Mono', monospace;
      font-size: 12px;
      font-weight: 400;
      color: var(--text-muted);
      letter-spacing: 0.15em;
      text-transform: uppercase;
      transition: all 0.15s ease;
      touch-action: manipulation;
    }

    .tap-tempo:active {
      transform: scale(0.96);
      background: rgba(212, 168, 83, 0.1);
      border-color: var(--amber);
      color: var(--amber);
    }

    .time-sig-selector {
      display: flex;
      gap: 8px;
    }

    .time-sig-btn {
      padding: 8px 16px;
      border-radius: 20px;
      background: var(--bg-surface);
      border: 1px solid rgba(232, 228, 220, 0.08);
      cursor: pointer;
      font-family: 'DM Mono', monospace;
      font-size: 12px;
      color: var(--text-muted);
      transition: all 0.15s ease;
    }

    .time-sig-btn:active {
      transform: scale(0.96);
    }

    .time-sig-btn.active {
      border-color: rgba(212, 168, 83, 0.4);
      color: var(--amber);
      background: rgba(212, 168, 83, 0.08);
    }

    /* Install button */
    .install-btn {
      position: absolute;
      left: 24px;
      top: calc(env(safe-area-inset-top) + 20px);
      height: 36px;
      padding: 0 14px;
      border: 1px solid rgba(232, 228, 220, 0.1);
      background: var(--bg-surface);
      border-radius: 18px;
      cursor: pointer;
      display: none;
      align-items: center;
      gap: 6px;
      font-family: 'DM Mono', monospace;
      font-size: 11px;
      color: var(--text-muted);
      letter-spacing: 0.05em;
      transition: all 0.2s ease;
    }

    .install-btn:active {
      transform: scale(0.96);
      border-color: var(--amber);
      color: var(--amber);
    }

    .install-btn svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
    }

    .install-btn.visible {
      display: flex;
      z-index: 110;
    }

    /* Install instructions modal */
    .install-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      z-index: 300;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
    }

    .install-modal.open {
      opacity: 1;
      pointer-events: auto;
    }

    .install-modal-content {
      background: var(--bg-surface);
      border-radius: 16px;
      padding: 28px 24px;
      max-width: 320px;
      width: 100%;
      text-align: center;
      transform: scale(0.95);
      transition: transform 0.25s ease;
    }

    .install-modal.open .install-modal-content {
      transform: scale(1);
    }

    .install-modal-title {
      font-family: 'Instrument Serif', serif;
      font-size: 20px;
      color: var(--text-primary);
      margin-bottom: 20px;
    }

    .install-step {
      display: flex;
      align-items: center;
      gap: 12px;
      text-align: left;
      padding: 10px 0;
    }

    .install-step-num {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: rgba(212, 168, 83, 0.12);
      color: var(--amber);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 13px;
      flex-shrink: 0;
    }

    .install-step-text {
      font-size: 13px;
      color: var(--text-primary);
      line-height: 1.4;
    }

    .install-step-text svg {
      width: 16px;
      height: 16px;
      fill: var(--amber);
      vertical-align: -3px;
    }

    .install-modal-close {
      margin-top: 20px;
      padding: 10px 28px;
      border-radius: 20px;
      background: rgba(212, 168, 83, 0.12);
      border: none;
      cursor: pointer;
      font-family: 'DM Mono', monospace;
      font-size: 12px;
      color: var(--amber);
      letter-spacing: 0.1em;
    }

    .install-modal-close:active {
      transform: scale(0.96);
    }

    /* Custom tuning */
    .custom-tuning-add {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 14px 24px;
      cursor: pointer;
      border: none;
      background: transparent;
      width: 100%;
      font-family: 'DM Mono', monospace;
      font-size: 13px;
      color: var(--amber);
      letter-spacing: 0.05em;
      transition: background 0.15s ease;
    }

    .custom-tuning-add:active {
      background: rgba(212, 168, 83, 0.1);
    }

    .custom-tuning-form {
      display: none;
      padding: 16px 24px;
      border-top: 1px solid rgba(232, 228, 220, 0.06);
      border-bottom: 1px solid rgba(232, 228, 220, 0.06);
    }

    .custom-tuning-form.open {
      display: block;
    }

    .custom-tuning-form label {
      display: block;
      font-size: 10px;
      font-weight: 500;
      color: var(--text-muted);
      letter-spacing: 0.1em;
      text-transform: uppercase;
      margin-bottom: 6px;
      margin-top: 12px;
    }

    .custom-tuning-form label:first-child {
      margin-top: 0;
    }

    .custom-tuning-name-input {
      width: 100%;
      padding: 10px 12px;
      background: var(--bg-deep);
      border: 1px solid rgba(232, 228, 220, 0.1);
      border-radius: 8px;
      font-family: 'DM Mono', monospace;
      font-size: 14px;
      color: var(--text-primary);
      outline: none;
    }

    .custom-tuning-name-input:focus {
      border-color: rgba(212, 168, 83, 0.4);
    }

    .custom-string-count {
      display: flex;
      gap: 6px;
    }

    .custom-string-count-btn {
      width: 40px;
      height: 36px;
      border-radius: 8px;
      background: var(--bg-deep);
      border: 1px solid rgba(232, 228, 220, 0.1);
      cursor: pointer;
      font-family: 'DM Mono', monospace;
      font-size: 13px;
      color: var(--text-muted);
      transition: all 0.15s ease;
    }

    .custom-string-count-btn.active {
      border-color: rgba(212, 168, 83, 0.4);
      color: var(--amber);
      background: rgba(212, 168, 83, 0.08);
    }

    .custom-string-rows {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .custom-string-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .custom-string-row span {
      font-size: 11px;
      color: var(--text-muted);
      width: 16px;
      text-align: center;
    }

    .custom-string-row select {
      flex: 1;
      padding: 8px 8px;
      background: var(--bg-deep);
      border: 1px solid rgba(232, 228, 220, 0.1);
      border-radius: 8px;
      font-family: 'DM Mono', monospace;
      font-size: 13px;
      color: var(--text-primary);
      appearance: none;
      -webkit-appearance: none;
      outline: none;
      cursor: pointer;
    }

    .custom-string-row select:focus {
      border-color: rgba(212, 168, 83, 0.4);
    }

    .custom-tuning-actions {
      display: flex;
      gap: 8px;
      margin-top: 16px;
    }

    .custom-tuning-actions button {
      flex: 1;
      padding: 10px;
      border-radius: 8px;
      font-family: 'DM Mono', monospace;
      font-size: 12px;
      letter-spacing: 0.05em;
      cursor: pointer;
      border: 1px solid rgba(232, 228, 220, 0.1);
      transition: all 0.15s ease;
    }

    .custom-tuning-save {
      background: rgba(212, 168, 83, 0.15);
      border-color: rgba(212, 168, 83, 0.3) !important;
      color: var(--amber);
    }

    .custom-tuning-cancel {
      background: transparent;
      color: var(--text-muted);
    }

    .delete-tuning-btn {
      width: 28px;
      height: 28px;
      border: none;
      background: transparent;
      border-radius: 50%;
      cursor: pointer;
      font-size: 14px;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s ease;
      flex-shrink: 0;
    }

    .delete-tuning-btn:active {
      background: rgba(239, 68, 68, 0.15);
      color: #ef4444;
    }

    /* === Recorder === */
    .recorder-container {
      flex: 1;
      display: none;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 400px;
      gap: 20px;
      padding-top: 8px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    .recorder-container.active {
      display: flex;
    }

    .recorder-status {
      text-align: center;
      min-height: 24px;
    }

    .recorder-status-text {
      font-size: 12px;
      font-weight: 400;
      color: var(--text-muted);
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }

    .recorder-status-text.recording {
      color: #ef4444;
    }

    .recorder-status-text.processing {
      color: var(--amber);
    }

    .recorder-status-text.ready {
      color: var(--color-perfect);
    }

    @keyframes rec-pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    .rec-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      background: #ef4444;
      border-radius: 50%;
      margin-right: 6px;
      vertical-align: middle;
      animation: rec-pulse 1s ease-in-out infinite;
    }

    .recorder-timer {
      font-family: 'Instrument Serif', serif;
      font-size: 64px;
      font-weight: 400;
      line-height: 1;
      color: var(--text-primary);
      text-align: center;
    }

    .recorder-timer.recording {
      color: #ef4444;
      text-shadow: 0 0 30px rgba(239, 68, 68, 0.3);
    }

    .recorder-controls {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .rec-btn {
      width: 64px;
      height: 64px;
      border-radius: 50%;
      border: 2px solid rgba(239, 68, 68, 0.4);
      background: var(--bg-surface);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .rec-btn:active {
      transform: scale(0.95);
    }

    .rec-btn .rec-btn-inner {
      width: 24px;
      height: 24px;
      background: #ef4444;
      border-radius: 50%;
      transition: all 0.2s ease;
    }

    .rec-btn.recording .rec-btn-inner {
      width: 20px;
      height: 20px;
      border-radius: 4px;
    }

    .rec-btn.recording {
      border-color: #ef4444;
      box-shadow: 0 0 20px rgba(239, 68, 68, 0.3);
    }

    .rec-secondary-btn {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 1px solid rgba(232, 228, 220, 0.1);
      background: var(--bg-surface);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s ease;
    }

    .rec-secondary-btn:active {
      transform: scale(0.92);
      border-color: var(--amber);
    }

    .rec-secondary-btn:disabled {
      opacity: 0.3;
      pointer-events: none;
    }

    .rec-secondary-btn svg {
      width: 18px;
      height: 18px;
      fill: var(--text-muted);
    }

    .recorder-progress {
      width: 100%;
      height: 4px;
      background: var(--bg-surface);
      border-radius: 2px;
      overflow: hidden;
      display: none;
    }

    .recorder-progress.active {
      display: block;
    }

    .recorder-progress-fill {
      height: 100%;
      width: 0%;
      background: var(--amber);
      border-radius: 2px;
      transition: width 0.15s linear;
    }

    .tab-output {
      width: 100%;
      display: none;
    }

    .tab-output.active {
      display: block;
    }

    .tab-output pre {
      width: 100%;
      padding: 16px;
      background: var(--bg-surface);
      border: 1px solid rgba(232, 228, 220, 0.06);
      border-radius: 12px;
      font-family: 'DM Mono', monospace;
      font-size: 12px;
      line-height: 1.6;
      color: var(--text-primary);
      overflow-x: auto;
      white-space: pre;
      -webkit-overflow-scrolling: touch;
      max-height: 200px;
      overflow-y: auto;
    }

    .tab-actions {
      display: flex;
      gap: 8px;
      margin-top: 8px;
    }

    .tab-action-btn {
      flex: 1;
      padding: 10px;
      border-radius: 8px;
      background: var(--bg-surface);
      border: 1px solid rgba(232, 228, 220, 0.1);
      cursor: pointer;
      font-family: 'DM Mono', monospace;
      font-size: 11px;
      color: var(--text-muted);
      letter-spacing: 0.1em;
      text-transform: uppercase;
      transition: all 0.15s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .tab-action-btn:active {
      transform: scale(0.96);
      border-color: var(--amber);
      color: var(--amber);
    }

    .tab-action-btn svg {
      width: 14px;
      height: 14px;
      fill: currentColor;
    }

    .saved-tabs {
      width: 100%;
      display: none;
    }

    .saved-tabs.has-tabs {
      display: block;
    }

    .saved-tabs-header {
      font-size: 10px;
      font-weight: 500;
      color: var(--text-muted);
      letter-spacing: 0.15em;
      text-transform: uppercase;
      margin-bottom: 8px;
    }

    .saved-tab-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: var(--bg-surface);
      border: 1px solid rgba(232, 228, 220, 0.06);
      border-radius: 8px;
      margin-bottom: 6px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .saved-tab-item:active {
      border-color: rgba(212, 168, 83, 0.3);
    }

    .saved-tab-name {
      font-size: 13px;
      color: var(--text-primary);
    }

    .saved-tab-date {
      font-size: 10px;
      color: var(--text-muted);
      margin-left: 8px;
    }

    .saved-tab-delete {
      width: 24px;
      height: 24px;
      border: none;
      background: transparent;
      border-radius: 50%;
      cursor: pointer;
      font-size: 14px;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .saved-tab-delete:active {
      background: rgba(239, 68, 68, 0.15);
      color: #ef4444;
    }

    .copy-toast {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      background: var(--bg-surface);
      border: 1px solid rgba(212, 168, 83, 0.3);
      border-radius: 20px;
      padding: 8px 20px;
      font-family: 'DM Mono', monospace;
      font-size: 12px;
      color: var(--amber);
      letter-spacing: 0.05em;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease, transform 0.2s ease;
      z-index: 200;
    }

    .copy-toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .spinner {
      display: inline-block;
      width: 14px;
      height: 14px;
      border: 2px solid rgba(212, 168, 83, 0.2);
      border-top-color: var(--amber);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      vertical-align: middle;
      margin-right: 6px;
    }
  </style>
</head>
<body>
  <div class="start-container" id="startContainer">
    <button class="start-btn" id="startBtn">
      <div class="start-icon"></div>
    </button>
    <p class="start-text">Tap to tune</p>
  </div>

  <header class="header">
    <h1 class="logo">Tuner</h1>
  </header>

  <button class="install-btn" id="installBtn">
    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
      <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
    </svg>
    Install
  </button>

  <div class="install-modal" id="installModal">
    <div class="install-modal-content">
      <h2 class="install-modal-title">Install Tuner</h2>
      <div id="installSteps"></div>
      <button class="install-modal-close" id="installModalClose">Got it</button>
    </div>
  </div>

  <div class="tuner-view-wrapper" id="tunerViewWrapper">

  <button class="mode-toggle" id="modeToggle" title="Switch meter mode">
    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
      <rect x="3" y="4" width="3" height="16" rx="1"/>
      <rect x="8.5" y="4" width="3" height="16" rx="1"/>
      <rect x="14" y="4" width="3" height="16" rx="1"/>
      <rect x="19.5" y="4" width="3" height="16" rx="1" opacity="0.5"/>
    </svg>
  </button>

  <button class="sound-toggle enabled" id="soundToggle" title="Toggle ping sound">
    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
      <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
    </svg>
  </button>

  <div class="level-meter" id="levelMeter">
    <div class="level-meter-fill" id="levelMeterFill"></div>
  </div>

  <main class="tuner-container" id="tunerContainer">
    <div class="note-display">
      <span class="current-note" id="currentNote">—</span>
      <span class="current-octave" id="currentOctave"></span>
      <p class="frequency" id="frequency">— Hz</p>
    </div>

    <div class="meter" id="meter">
      <svg class="meter-svg" viewBox="0 0 300 140">
        <!-- Arc track -->
        <path class="meter-track" d="M 30 130 A 120 120 0 0 1 270 130" />

        <!-- Tick marks -->
        <g class="meter-ticks">
          <line x1="30" y1="130" x2="40" y2="122" />
          <line x1="60" y1="95" x2="68" y2="102" />
          <line x1="100" y1="70" x2="105" y2="79" />
          <line x1="150" y1="55" x2="150" y2="66" class="center-tick" />
          <line x1="200" y1="70" x2="195" y2="79" />
          <line x1="240" y1="95" x2="232" y2="102" />
          <line x1="270" y1="130" x2="260" y2="122" />
        </g>

        <!-- Labels -->
        <g class="meter-labels">
          <text x="22" y="138" text-anchor="start">♭</text>
          <text x="150" y="48" text-anchor="middle" class="center-label">●</text>
          <text x="278" y="138" text-anchor="end">♯</text>
        </g>
      </svg>

      <div class="strobe-container" id="strobeContainer">
        <canvas class="strobe-canvas" id="strobeCanvas"></canvas>
      </div>

      <div class="needle-container" id="needle">
        <div class="needle"></div>
        <div class="needle-tip"></div>
        <div class="needle-base"></div>
      </div>
    </div>

    <p class="strobe-hint">Bars stop moving when in tune.<br>Left = flat, right = sharp.</p>

    <div class="cents-display">
      <span class="cents-value" id="centsValue">0</span> cents
    </div>
  </main>

  <!-- Tuning Modal -->
  <div class="tuning-modal" id="tuningModal">
    <div class="tuning-modal-content">
      <div class="tuning-modal-header">
        <h2 class="tuning-modal-title">Select Tuning</h2>
        <button class="tuning-modal-close" id="closeTuningModal">&times;</button>
      </div>
      <button class="custom-tuning-add" id="addCustomTuningBtn">+ Add Custom Tuning</button>

      <div class="custom-tuning-form" id="customTuningForm">
        <label>Tuning Name</label>
        <input type="text" class="custom-tuning-name-input" id="customTuningName" placeholder="My Tuning" maxlength="30">

        <label>Strings</label>
        <div class="custom-string-count" id="customStringCount"></div>

        <label>Notes</label>
        <div class="custom-string-row" style="margin-bottom: 4px;">
          <span></span>
          <span style="flex:1; font-size:10px; color:var(--text-muted); letter-spacing:0.1em; text-transform:uppercase;">Note</span>
          <span style="flex:1; font-size:10px; color:var(--text-muted); letter-spacing:0.1em; text-transform:uppercase;">Octave</span>
        </div>
        <div class="custom-string-rows" id="customStringRows"></div>

        <div class="custom-tuning-actions">
          <button class="custom-tuning-cancel" id="customTuningCancel">Cancel</button>
          <button class="custom-tuning-save" id="customTuningSave">Save</button>
        </div>
      </div>

      <div id="tuningList"></div>
    </div>
  </div>

  <nav class="strings-container">
    <div class="tuning-selector" id="tuningSelector">
      <span class="tuning-name" id="currentTuningName">Standard</span>
      <span class="tuning-arrow"></span>
    </div>
    <div class="strings" id="strings"></div>
  </nav>

  </div><!-- /tuner-view-wrapper -->

  <!-- Metronome View -->
  <div class="metronome-container" id="metronomeContainer">
    <div class="bpm-display">
      <div class="bpm-value" id="bpmValue">120</div>
      <div class="bpm-label">BPM</div>
    </div>

    <div class="bpm-controls">
      <button class="bpm-btn" id="bpmDown">&minus;</button>
      <button class="bpm-btn" id="bpmUp">+</button>
    </div>

    <div class="beat-indicators" id="beatIndicators"></div>

    <button class="metronome-play" id="metronomePlay">
      <svg id="playIcon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M8 5v14l11-7z"/>
      </svg>
    </button>

    <button class="tap-tempo" id="tapTempo">Tap Tempo</button>

    <div class="time-sig-selector" id="timeSigSelector">
      <button class="time-sig-btn active" data-beats="4">4/4</button>
      <button class="time-sig-btn" data-beats="3">3/4</button>
      <button class="time-sig-btn" data-beats="6">6/8</button>
    </div>
  </div>

  <!-- Recorder View -->
  <div class="recorder-container" id="recorderContainer">
    <div class="recorder-status">
      <span class="recorder-status-text" id="recorderStatus">Ready to record</span>
    </div>

    <div class="recorder-timer" id="recorderTimer">0:00</div>

    <div class="recorder-controls">
      <button class="rec-secondary-btn" id="recClearBtn" disabled title="Clear">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
        </svg>
      </button>
      <button class="rec-btn" id="recBtn" title="Record">
        <div class="rec-btn-inner"></div>
      </button>
      <button class="rec-secondary-btn" id="recClearBtn2" style="visibility:hidden">
        <svg viewBox="0 0 24 24"><path d="M0 0"/></svg>
      </button>
    </div>

    <div class="recorder-progress" id="recorderProgress">
      <div class="recorder-progress-fill" id="recorderProgressFill"></div>
    </div>

    <div class="tab-output" id="tabOutput">
      <pre id="tabPre"></pre>
      <div class="tab-actions">
        <button class="tab-action-btn" id="copyTabBtn">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/>
          </svg>
          Copy
        </button>
        <button class="tab-action-btn" id="saveTabBtn">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/>
          </svg>
          Save
        </button>
      </div>
    </div>

    <div class="saved-tabs" id="savedTabsList">
      <div class="saved-tabs-header">Saved Tabs</div>
      <div id="savedTabsItems"></div>
    </div>
  </div>

  <div class="copy-toast" id="copyToast">Copied to clipboard</div>

  <!-- Tab Bar -->
  <nav class="tab-bar">
    <button class="tab-bar-btn active" id="tabTuner" data-view="tuner">
      <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v5.27l4.5 2.67-.75 1.27L11 13V7z"/>
      </svg>
      <span>Tuner</span>
    </button>
    <button class="tab-bar-btn" id="tabMetronome" data-view="metronome">
      <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M12 2L6 22h12L12 2zm0 5.5l3.5 12.5h-7L12 7.5zM11 14h2v4h-2v-4z"/>
      </svg>
      <span>Metronome</span>
    </button>
    <button class="tab-bar-btn" id="tabRecorder" data-view="recorder">
      <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M3 17h2v5H3v-5zm4-5h2v10H7V12zm4-4h2v14h-2V8zm4-3h2v17h-2V5zm4-3h2v20h-2V2z"/>
      </svg>
      <span>Tab</span>
    </button>
  </nav>

  <script>
    // Audio context and analyser
    let audioContext;
    let analyser;
    let mediaStream;
    let isListening = false;

    // Strobe mode
    let meterMode = localStorage.getItem('meterMode') || 'needle';
    let strobePhase = 0;
    let strobeCanvas, strobeCtx;

    // View state
    let currentView = 'tuner';

    // Metronome state
    let metronomePlaying = false;
    let metronomeBpm = parseInt(localStorage.getItem('metronomeBpm')) || 120;
    let metronomeBeats = parseInt(localStorage.getItem('metronomeBeats')) || 4;
    let metronomeCurrentBeat = 0;
    let metronomeTimerId = null;
    let nextNoteTime = 0;
    let tapTimes = [];
    const LOOKAHEAD = 25;
    const SCHEDULE_AHEAD = 0.1;

    // Note frequencies (A4 = 440Hz)
    const A4 = 440;
    const NOTES = ['C', 'C♯', 'D', 'D♯', 'E', 'F', 'F♯', 'G', 'G♯', 'A', 'A♯', 'B'];

    // All tunings organized by category
    const TUNINGS = {
      'Standard': [
        { name: 'Standard', notes: ['E2', 'A2', 'D3', 'G3', 'B3', 'E4'], freqs: [82.41, 110.00, 146.83, 196.00, 246.94, 329.63] },
        { name: 'Half Step Down', notes: ['E♭2', 'A♭2', 'D♭3', 'G♭3', 'B♭3', 'E♭4'], freqs: [77.78, 103.83, 138.59, 185.00, 233.08, 311.13] },
        { name: 'Full Step Down', notes: ['D2', 'G2', 'C3', 'F3', 'A3', 'D4'], freqs: [73.42, 98.00, 130.81, 174.61, 220.00, 293.66] },
      ],
      'Drop': [
        { name: 'Drop D', notes: ['D2', 'A2', 'D3', 'G3', 'B3', 'E4'], freqs: [73.42, 110.00, 146.83, 196.00, 246.94, 329.63] },
        { name: 'Drop C', notes: ['C2', 'G2', 'C3', 'F3', 'A3', 'D4'], freqs: [65.41, 98.00, 130.81, 174.61, 220.00, 293.66] },
        { name: 'Drop B', notes: ['B1', 'F♯2', 'B2', 'E3', 'G♯3', 'C♯4'], freqs: [61.74, 92.50, 123.47, 164.81, 207.65, 277.18] },
        { name: 'Drop A', notes: ['A1', 'E2', 'A2', 'D3', 'F♯3', 'B3'], freqs: [55.00, 82.41, 110.00, 146.83, 185.00, 246.94] },
      ],
      'Open': [
        { name: 'Open G', notes: ['D2', 'G2', 'D3', 'G3', 'B3', 'D4'], freqs: [73.42, 98.00, 146.83, 196.00, 246.94, 293.66] },
        { name: 'Open D', notes: ['D2', 'A2', 'D3', 'F♯3', 'A3', 'D4'], freqs: [73.42, 110.00, 146.83, 185.00, 220.00, 293.66] },
        { name: 'Open E', notes: ['E2', 'B2', 'E3', 'G♯3', 'B3', 'E4'], freqs: [82.41, 123.47, 164.81, 207.65, 246.94, 329.63] },
        { name: 'Open A', notes: ['E2', 'A2', 'E3', 'A3', 'C♯4', 'E4'], freqs: [82.41, 110.00, 164.81, 220.00, 277.18, 329.63] },
        { name: 'Open C', notes: ['C2', 'G2', 'C3', 'G3', 'C4', 'E4'], freqs: [65.41, 98.00, 130.81, 196.00, 261.63, 329.63] },
      ],
      'Alternate': [
        { name: 'DADGAD', notes: ['D2', 'A2', 'D3', 'G3', 'A3', 'D4'], freqs: [73.42, 110.00, 146.83, 196.00, 220.00, 293.66] },
        { name: 'Double Drop D', notes: ['D2', 'A2', 'D3', 'G3', 'B3', 'D4'], freqs: [73.42, 110.00, 146.83, 196.00, 246.94, 293.66] },
        { name: 'C6', notes: ['C2', 'A2', 'C3', 'G3', 'C4', 'E4'], freqs: [65.41, 110.00, 130.81, 196.00, 261.63, 329.63] },
        { name: 'All Fourths', notes: ['E2', 'A2', 'D3', 'G3', 'C4', 'F4'], freqs: [82.41, 110.00, 146.83, 196.00, 261.63, 349.23] },
        { name: 'NST (Fripp)', notes: ['C2', 'G2', 'D3', 'A3', 'E4', 'G4'], freqs: [65.41, 98.00, 146.83, 220.00, 329.63, 392.00] },
      ]
    };

    let currentTuning = TUNINGS['Standard'][0];

    // DOM elements
    const startContainer = document.getElementById('startContainer');
    const startBtn = document.getElementById('startBtn');
    const tunerContainer = document.getElementById('tunerContainer');
    const currentNoteEl = document.getElementById('currentNote');
    const currentOctaveEl = document.getElementById('currentOctave');
    const frequencyEl = document.getElementById('frequency');
    const needleEl = document.getElementById('needle');
    const meterEl = document.getElementById('meter');
    const centsValueEl = document.getElementById('centsValue');
    const stringsEl = document.getElementById('strings');
    const tuningSelector = document.getElementById('tuningSelector');
    const tuningModal = document.getElementById('tuningModal');
    const closeTuningModal = document.getElementById('closeTuningModal');
    const tuningList = document.getElementById('tuningList');
    const currentTuningName = document.getElementById('currentTuningName');

    // Render string buttons for current tuning
    function renderStrings() {
      stringsEl.innerHTML = currentTuning.notes.map((note, i) => {
        const displayNote = note.replace(/[0-9]/g, '');
        return `
          <button class="string-btn" data-freq="${currentTuning.freqs[i]}">
            <span class="string-note">${displayNote}</span>
            <span class="string-number">${6 - i}</span>
          </button>
        `;
      }).join('');
    }

    // Render tuning modal list
    function renderTuningList() {
      tuningList.innerHTML = Object.entries(TUNINGS).map(([category, tunings]) => `
        <div class="tuning-category">
          <span class="tuning-category-label">${category}</span>
        </div>
        ${tunings.map(tuning => `
          <button class="tuning-option ${tuning.name === currentTuning.name ? 'active' : ''}" data-tuning="${tuning.name}">
            <span class="tuning-option-name">${tuning.name}</span>
            <span class="tuning-option-notes">${tuning.notes.map(n => n.replace(/[0-9]/g, '')).join(' ')}</span>
          </button>
        `).join('')}
      `).join('');
    }

    // Select a tuning
    function selectTuning(tuningName) {
      for (const category of Object.values(TUNINGS)) {
        const found = category.find(t => t.name === tuningName);
        if (found) {
          currentTuning = found;
          break;
        }
      }
      currentTuningName.textContent = currentTuning.name;
      renderStrings();
      renderTuningList();
      closeTuningModalFn();

      // Save preference
      localStorage.setItem('selectedTuning', currentTuning.name);
    }

    // Open/close modal
    function openTuningModal() {
      tuningModal.classList.add('open');
      tuningSelector.classList.add('open');
    }

    function closeTuningModalFn() {
      tuningModal.classList.remove('open');
      tuningSelector.classList.remove('open');
    }

    // Convert frequency to note
    function frequencyToNote(freq) {
      const noteNum = 12 * (Math.log2(freq / A4));
      const noteIndex = Math.round(noteNum) + 69; // MIDI note number
      const cents = Math.round((noteNum - Math.round(noteNum)) * 100);
      const octave = Math.floor(noteIndex / 12) - 1;
      const note = NOTES[noteIndex % 12];

      return { note, octave, cents, noteIndex };
    }

    // Frequency smoothing - much more aggressive
    const frequencyHistory = [];
    const HISTORY_SIZE = 6;
    let lastValidFrequency = -1;
    let lockedNoteIndex = -1;

    // Decay compensation
    let referenceRMS = 0;
    let prevLockedNote = -1;
    const MAX_GAIN = 60;
    let smoothedFrequency = -1;
    let displayedCents = 0;
    let stableCount = 0;
    const EMA_ALPHA = 0.2; // Exponential moving average factor (lower = smoother)

    // Pre-compute Hanning window
    let hanningWindow = null;

    function getHanningWindow(size) {
      if (!hanningWindow || hanningWindow.length !== size) {
        hanningWindow = new Float32Array(size);
        for (let i = 0; i < size; i++) {
          hanningWindow[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (size - 1)));
        }
      }
      return hanningWindow;
    }

    // YIN pitch detection algorithm (more accurate than simple autocorrelation)
    function yinPitchDetect(buffer, sampleRate) {
      const SIZE = buffer.length;
      const yinBufferSize = Math.floor(SIZE / 2);
      const yinBuffer = new Float32Array(yinBufferSize);
      const threshold = 0.15;

      // Apply Hanning window for better detection of weak signals
      const window = getHanningWindow(SIZE);
      const windowed = new Float32Array(SIZE);
      let rms = 0;
      for (let i = 0; i < SIZE; i++) {
        windowed[i] = buffer[i] * window[i];
        rms += buffer[i] * buffer[i];
      }
      rms = Math.sqrt(rms / SIZE);

      // Not enough signal
      if (rms < 0.01) return { frequency: -1, confidence: 0 };

      // Step 1: Compute the difference function
      let runningSum = 0;
      yinBuffer[0] = 1;

      for (let tau = 1; tau < yinBufferSize; tau++) {
        yinBuffer[tau] = 0;
        for (let i = 0; i < yinBufferSize; i++) {
          const delta = windowed[i] - windowed[i + tau];
          yinBuffer[tau] += delta * delta;
        }
        runningSum += yinBuffer[tau];
        // Cumulative mean normalized difference
        yinBuffer[tau] *= tau / runningSum;
      }

      // Step 2: Find the first dip below threshold
      let tauEstimate = -1;
      for (let tau = 2; tau < yinBufferSize; tau++) {
        if (yinBuffer[tau] < threshold) {
          while (tau + 1 < yinBufferSize && yinBuffer[tau + 1] < yinBuffer[tau]) {
            tau++;
          }
          tauEstimate = tau;
          break;
        }
      }

      if (tauEstimate === -1) return { frequency: -1, confidence: 0 };

      // Step 3: Parabolic interpolation for better precision
      let betterTau;
      const x0 = tauEstimate < 1 ? tauEstimate : tauEstimate - 1;
      const x2 = tauEstimate + 1 < yinBufferSize ? tauEstimate + 1 : tauEstimate;

      if (x0 === tauEstimate) {
        betterTau = yinBuffer[tauEstimate] <= yinBuffer[x2] ? tauEstimate : x2;
      } else if (x2 === tauEstimate) {
        betterTau = yinBuffer[tauEstimate] <= yinBuffer[x0] ? tauEstimate : x0;
      } else {
        const s0 = yinBuffer[x0];
        const s1 = yinBuffer[tauEstimate];
        const s2 = yinBuffer[x2];
        betterTau = tauEstimate + (s2 - s0) / (2 * (2 * s1 - s2 - s0));
      }

      const frequency = sampleRate / betterTau;
      const confidence = 1 - yinBuffer[tauEstimate];

      return { frequency, confidence };
    }

    // FFT spectral peak tracking - used when we have a locked note
    // Finds the peak near the expected frequency (and its harmonics)
    // Works much deeper into decay than YIN because FFT concentrates
    // energy into narrow bins and ignores everything else
    let freqDataBuffer = null;

    function trackPitchFFT(expectedFreq) {
      if (!analyser || !audioContext) return { frequency: -1, confidence: 0 };

      const fftSize = analyser.fftSize;
      if (!freqDataBuffer || freqDataBuffer.length !== fftSize / 2) {
        freqDataBuffer = new Float32Array(fftSize / 2);
      }
      analyser.getFloatFrequencyData(freqDataBuffer);

      const sampleRate = audioContext.sampleRate;
      const binWidth = sampleRate / fftSize;

      let bestFreq = -1;
      let bestConfidence = 0;

      // Check fundamental + harmonics 2-5
      // Upper harmonics often persist longer than the fundamental on guitar
      for (let h = 1; h <= 5; h++) {
        const searchFreq = expectedFreq * h;
        if (searchFreq > sampleRate / 2) break; // above Nyquist

        const expectedBin = searchFreq / binWidth;
        // Search within ±1 semitone
        const searchRange = Math.max(3, Math.ceil(expectedBin * 0.06));
        const minBin = Math.max(1, Math.floor(expectedBin - searchRange));
        const maxBin = Math.min(freqDataBuffer.length - 2, Math.ceil(expectedBin + searchRange));

        // Find peak in range
        let peakBin = minBin;
        let peakVal = freqDataBuffer[minBin];
        for (let i = minBin + 1; i <= maxBin; i++) {
          if (freqDataBuffer[i] > peakVal) {
            peakVal = freqDataBuffer[i];
            peakBin = i;
          }
        }

        // Must be above noise floor (dB scale)
        if (peakVal < -90) continue;

        // Parabolic interpolation for sub-bin precision
        const alpha = freqDataBuffer[peakBin - 1];
        const beta = freqDataBuffer[peakBin];
        const gamma = freqDataBuffer[peakBin + 1];
        const denom = alpha - 2 * beta + gamma;
        const p = denom !== 0 ? 0.5 * (alpha - gamma) / denom : 0;

        const interpolatedBin = peakBin + p;
        const harmonicFreq = interpolatedBin * binWidth;
        const derivedFundamental = harmonicFreq / h;

        // Confidence from peak prominence above neighbors
        const windowSize = 5;
        let noiseFloor = 0;
        let count = 0;
        for (let i = Math.max(0, peakBin - windowSize * 2); i <= Math.min(freqDataBuffer.length - 1, peakBin + windowSize * 2); i++) {
          if (Math.abs(i - peakBin) > windowSize) {
            noiseFloor += freqDataBuffer[i];
            count++;
          }
        }
        noiseFloor = count > 0 ? noiseFloor / count : -100;
        const prominence = beta - noiseFloor;
        // Weight lower harmonics slightly higher (more reliable)
        const harmonicWeight = 1 - (h - 1) * 0.1;
        const confidence = Math.min(1, (prominence / 15) * harmonicWeight);

        if (confidence > bestConfidence) {
          bestConfidence = confidence;
          bestFreq = derivedFundamental;
        }
      }

      return { frequency: bestFreq, confidence: bestConfidence };
    }

    // Targeted autocorrelation refinement — given a rough frequency estimate
    // from FFT, searches a narrow range of lags for the precise pitch.
    // Much faster than full YIN (checks ~60 lags vs ~2000) and more precise
    // than FFT alone, especially for low frequencies.
    function refinePitch(buffer, roughFreq, sampleRate) {
      const expectedLag = sampleRate / roughFreq;
      // Search ±1 semitone
      const searchRange = Math.max(4, Math.ceil(expectedLag * 0.06));
      const minLag = Math.max(2, Math.floor(expectedLag - searchRange));
      const maxLag = Math.min(Math.floor(buffer.length / 2), Math.ceil(expectedLag + searchRange));

      const N = Math.min(buffer.length, 4096);
      let bestLag = expectedLag;
      let bestCorr = -1;
      const correlations = new Float32Array(maxLag - minLag + 1);

      for (let lag = minLag; lag <= maxLag; lag++) {
        let corr = 0, e1 = 0, e2 = 0;
        for (let i = 0; i < N - lag; i++) {
          corr += buffer[i] * buffer[i + lag];
          e1 += buffer[i] * buffer[i];
          e2 += buffer[i + lag] * buffer[i + lag];
        }
        const norm = Math.sqrt(e1 * e2);
        const normalized = norm > 0 ? corr / norm : 0;
        correlations[lag - minLag] = normalized;
        if (normalized > bestCorr) {
          bestCorr = normalized;
          bestLag = lag;
        }
      }

      // Parabolic interpolation for sub-sample precision
      const idx = bestLag - minLag;
      if (idx > 0 && idx < correlations.length - 1) {
        const a = correlations[idx - 1];
        const b = correlations[idx];
        const c = correlations[idx + 1];
        const denom = a - 2 * b + c;
        if (denom !== 0) {
          const p = 0.5 * (a - c) / denom;
          bestLag = bestLag + p;
        }
      }

      return sampleRate / bestLag;
    }

    // Smooth frequency readings with aggressive filtering
    function smoothFrequency(newFreq) {
      if (newFreq === -1) {
        stableCount = Math.max(0, stableCount - 1);
        if (stableCount === 0) {
          frequencyHistory.length = 0;
        }
        return smoothedFrequency > 0 ? smoothedFrequency : -1;
      }

      // Check if new frequency is close to recent readings
      if (lastValidFrequency > 0) {
        const ratio = newFreq / lastValidFrequency;
        // If jumping more than a semitone, it's probably a different note or noise
        if (ratio < 0.94 || ratio > 1.06) {
          // Reset for new note
          frequencyHistory.length = 0;
          stableCount = 0;
          smoothedFrequency = -1;
          lastValidFrequency = -1;
        }
      }

      frequencyHistory.push(newFreq);
      if (frequencyHistory.length > HISTORY_SIZE) {
        frequencyHistory.shift();
      }

      // Need at least 4 readings before showing anything
      if (frequencyHistory.length < 2) return -1;

      // Filter out outliers using median
      const sorted = [...frequencyHistory].sort((a, b) => a - b);
      const median = sorted[Math.floor(sorted.length / 2)];

      // Only keep values within 3% of median (tighter filter)
      const filtered = frequencyHistory.filter(f => {
        const ratio = f / median;
        return ratio > 0.97 && ratio < 1.03;
      });

      // Need at least 3 consistent readings
      if (filtered.length < 2) return smoothedFrequency > 0 ? smoothedFrequency : -1;

      const avg = filtered.reduce((a, b) => a + b, 0) / filtered.length;

      // Apply exponential moving average for smooth transitions
      if (smoothedFrequency < 0) {
        smoothedFrequency = avg;
      } else {
        smoothedFrequency = EMA_ALPHA * avg + (1 - EMA_ALPHA) * smoothedFrequency;
      }

      lastValidFrequency = smoothedFrequency;
      stableCount = Math.min(stableCount + 1, 20);

      return smoothedFrequency;
    }

    // Smooth cents display to prevent jitter
    function smoothCents(rawCents) {
      const diff = rawCents - displayedCents;
      // Only update if change is significant (> 1 cent) or we're close to target
      if (Math.abs(diff) > 1) {
        // Move towards target, but smoothly
        displayedCents += diff * 0.3;
      }
      return Math.round(displayedCents);
    }

    // Get color based on how many cents off
    function getTuneColor(cents) {
      const absCents = Math.abs(cents);

      if (absCents <= 5) {
        // Perfect - bright green
        return { color: '#4ade80', glow: 'rgba(74, 222, 128, 0.5)' };
      } else if (absCents <= 10) {
        // Very close - green-yellow
        return { color: '#a3e635', glow: 'rgba(163, 230, 53, 0.4)' };
      } else if (absCents <= 20) {
        // Close - yellow
        return { color: '#facc15', glow: 'rgba(250, 204, 21, 0.4)' };
      } else if (absCents <= 35) {
        // Medium - orange
        return { color: '#f97316', glow: 'rgba(249, 115, 22, 0.4)' };
      } else {
        // Far - red
        return { color: '#ef4444', glow: 'rgba(239, 68, 68, 0.4)' };
      }
    }

    // Last displayed values for skipping redundant DOM updates
    let lastDisplayedNote = '';
    let lastDisplayedOctave = '';
    let lastDisplayedCents = null;
    let lastDisplayedColor = '';
    let lastClosestIdx = -1;
    let lastNoSignal = false;

    // In-tune ping sound
    let wasInTune = false;
    let lastPingTime = 0;
    let pingEnabled = localStorage.getItem('pingEnabled') !== 'false'; // default on
    const PING_COOLDOWN = 800; // ms between pings

    // Haptic feedback
    function triggerHaptic() {
      try {
        if (navigator.vibrate) {
          navigator.vibrate(50);
        }
      } catch (e) { /* ignore */ }
    }

    function playInTunePing() {
      if (!audioContext || !pingEnabled) return;

      const now = Date.now();
      if (now - lastPingTime < PING_COOLDOWN) return;
      lastPingTime = now;

      // Create a pleasant "ding" sound
      const osc1 = audioContext.createOscillator();
      const osc2 = audioContext.createOscillator();
      const gainNode = audioContext.createGain();

      // Two oscillators for a richer tone
      osc1.type = 'sine';
      osc1.frequency.value = 880; // A5

      osc2.type = 'sine';
      osc2.frequency.value = 1320; // E6 (perfect fifth above)

      // Quick attack, gentle decay
      gainNode.gain.setValueAtTime(0, audioContext.currentTime);
      gainNode.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 0.02);
      gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.4);

      osc1.connect(gainNode);
      osc2.connect(gainNode);
      gainNode.connect(audioContext.destination);

      osc1.start();
      osc2.start();
      osc1.stop(audioContext.currentTime + 0.4);
      osc2.stop(audioContext.currentTime + 0.4);
    }

    // Update display
    function updateDisplay(frequency) {
      if (frequency === -1 || frequency < 60 || frequency > 1000) {
        if (!lastNoSignal) {
          tunerContainer.classList.add('no-signal');
          lastNoSignal = true;
          // Clear auto-detect highlighting
          document.querySelectorAll('.string-btn').forEach(btn => btn.classList.remove('auto-detected'));
          lastClosestIdx = -1;
          lockedNoteIndex = -1;
        }
        return;
      }

      if (lastNoSignal) {
        tunerContainer.classList.remove('no-signal');
        lastNoSignal = false;
      }

      const { note, octave, cents: rawCents, noteIndex } = frequencyToNote(frequency);
      lockedNoteIndex = noteIndex;

      // Apply smoothing to cents for stable display
      const cents = smoothCents(rawCents);

      if (note !== lastDisplayedNote) {
        currentNoteEl.textContent = note;
        lastDisplayedNote = note;
      }
      if (octave !== lastDisplayedOctave) {
        currentOctaveEl.textContent = octave;
        lastDisplayedOctave = octave;
      }

      frequencyEl.textContent = `${frequency.toFixed(1)} Hz`;

      if (cents !== lastDisplayedCents) {
        // Update cents
        const centsPrefix = cents > 0 ? '+' : '';
        centsValueEl.textContent = `${centsPrefix}${cents}`;

        // Update needle (map cents to angle, -50 to +50 cents = -45 to +45 degrees)
        const angle = (cents / 50) * 45;
        const clampedAngle = Math.max(-45, Math.min(45, angle));
        needleEl.style.transform = `translateX(-50%) rotate(${clampedAngle}deg)`;

        lastDisplayedCents = cents;
      }

      // Update colors based on accuracy
      const { color, glow } = getTuneColor(cents);
      if (color !== lastDisplayedColor) {
        document.documentElement.style.setProperty('--tune-color', color);
        document.documentElement.style.setProperty('--tune-glow', glow);
        lastDisplayedColor = color;
      }

      // Update strobe if in strobe mode
      drawStrobe(cents);

      // Auto-detect closest string
      let closestIdx = 0;
      let closestDist = Infinity;
      currentTuning.freqs.forEach((f, i) => {
        const dist = Math.abs(12 * Math.log2(frequency / f));
        if (dist < closestDist) {
          closestDist = dist;
          closestIdx = i;
        }
      });
      document.querySelectorAll('.string-btn').forEach((btn, i) => {
        btn.classList.toggle('auto-detected', i === closestIdx && closestDist < 2);
      });
      lastClosestIdx = closestIdx;

      // Play ping when transitioning to in-tune
      const isInTune = Math.abs(cents) <= 5;
      if (isInTune && !wasInTune) {
        playInTunePing();
        triggerHaptic();
      }
      wasInTune = isInTune;
    }

    // Start listening
    async function startListening() {
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 16384; // Maximum buffer for tracking weak/decaying signals
        analyser.smoothingTimeConstant = 0.5; // Lower = more responsive FFT
        analyser.minDecibels = -130; // Wider dynamic range for weak signals

        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const source = audioContext.createMediaStreamSource(mediaStream);
        source.connect(analyser);

        isListening = true;
        startContainer.classList.add('hidden');

        // Start detection loop
        const buffer = new Float32Array(analyser.fftSize);

        const levelMeter = document.getElementById('levelMeter');
        const levelMeterFill = document.getElementById('levelMeterFill');
        levelMeter.classList.add('active');

        // Use a 4096 subarray for YIN (16x faster than full 16384)
        const yinBuffer = new Float32Array(4096);
        let yinSkipCounter = 0;

        // Performance monitoring
        let perfSamples = [];
        let perfInterval = setInterval(() => {
          if (perfSamples.length > 0) {
            const avg = perfSamples.reduce((a, b) => a + b) / perfSamples.length;
            const max = Math.max(...perfSamples);
            console.log(`[tuner perf] avg: ${avg.toFixed(1)}ms, max: ${max.toFixed(1)}ms, fps: ${perfSamples.length} (${perfSamples.length < 50 ? 'SLOW' : 'ok'})`);
            perfSamples = [];
          }
        }, 1000);

        function detect() {
          if (!isListening) return;
          const t0 = performance.now();

          analyser.getFloatTimeDomainData(buffer);

          // Compute raw RMS for level meter (sample every 4th for speed)
          let rawRMS = 0;
          for (let i = 0; i < buffer.length; i += 4) {
            rawRMS += buffer[i] * buffer[i];
          }
          rawRMS = Math.sqrt(rawRMS / (buffer.length / 4));
          const levelPct = Math.min(100, rawRMS * 500);
          levelMeterFill.style.width = levelPct + '%';
          levelMeterFill.classList.toggle('hot', levelPct > 70);
          levelMeterFill.classList.toggle('clip', levelPct > 90);

          let rawFreq, confidence;

          if (lockedNoteIndex >= 0 && smoothedFrequency > 0) {
            // TRACKING MODE: FFT spectral peak tracking (fast)
            const fftResult = trackPitchFFT(smoothedFrequency);

            if (fftResult.confidence > 0.3) {
              // Refine the FFT estimate with targeted autocorrelation
              // Critical for low strings where FFT bin resolution is poor
              rawFreq = refinePitch(buffer, fftResult.frequency, audioContext.sampleRate);
              confidence = fftResult.confidence;
            } else {
              rawFreq = -1;
              confidence = 0;
            }

            // Run YIN only every 10th frame AND only on strong signal
            // Uses last 4096 samples (not full 16384) for 16x speedup
            yinSkipCounter++;
            if (rawRMS > 0.03 && yinSkipCounter >= 10) {
              yinSkipCounter = 0;
              // Copy last 4096 samples from the full buffer
              yinBuffer.set(buffer.subarray(buffer.length - 4096));
              const yinResult = yinPitchDetect(yinBuffer, audioContext.sampleRate);
              if (yinResult.confidence > 0.93 && yinResult.frequency > 0) {
                const yinNoteIndex = Math.round(12 * Math.log2(yinResult.frequency / A4)) + 69;
                if (yinNoteIndex !== lockedNoteIndex) {
                  rawFreq = yinResult.frequency;
                  confidence = yinResult.confidence;
                }
              }
            }
          } else {
            // ACQUISITION MODE: YIN on 4096 samples (fast)
            yinBuffer.set(buffer.subarray(buffer.length - 4096));
            const yinResult = yinPitchDetect(yinBuffer, audioContext.sampleRate);
            rawFreq = yinResult.frequency;
            confidence = yinResult.confidence;
          }

          const confThreshold = lockedNoteIndex >= 0 ? 0.25 : 0.5;
          const frequency = confidence > confThreshold ? smoothFrequency(rawFreq) : smoothFrequency(-1);
          updateDisplay(frequency);

          perfSamples.push(performance.now() - t0);
          requestAnimationFrame(detect);
        }

        detect();
      } catch (err) {
        console.error('Microphone access denied:', err);
        alert('Please allow microphone access to use the tuner.');
      }
    }

    // Play reference tone
    function playReferenceTone(frequency) {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (audioContext.state === 'suspended') {
        audioContext.resume();
      }

      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();

      oscillator.type = 'sine';
      oscillator.frequency.value = frequency;

      gainNode.gain.setValueAtTime(0, audioContext.currentTime);
      gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.05);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1.5);

      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);

      oscillator.start();
      oscillator.stop(audioContext.currentTime + 1.5);
    }

    // Strobe rendering
    function initStrobe() {
      strobeCanvas = document.getElementById('strobeCanvas');
      strobeCtx = strobeCanvas.getContext('2d');
      resizeStrobe();
    }

    function resizeStrobe() {
      if (!strobeCanvas) return;
      const rect = strobeCanvas.parentElement.getBoundingClientRect();
      strobeCanvas.width = rect.width * window.devicePixelRatio;
      strobeCanvas.height = rect.height * window.devicePixelRatio;
      strobeCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
    }

    function hexToRgb(hex) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return { r, g, b };
    }

    function drawStrobe(cents) {
      if (!strobeCtx || meterMode !== 'strobe') return;

      const w = strobeCanvas.width / window.devicePixelRatio;
      const h = strobeCanvas.height / window.devicePixelRatio;

      strobePhase += cents * 0.4;

      strobeCtx.clearRect(0, 0, w, h);

      // Background
      strobeCtx.fillStyle = '#0a0a0a';
      strobeCtx.fillRect(0, 0, w, h);

      const { color } = getTuneColor(cents);
      const rgb = hexToRgb(color);
      const barWidth = 18;
      const gap = 18;
      const period = barWidth + gap;
      const offset = ((strobePhase % period) + period) % period;

      for (let x = -period + offset; x < w + period; x += period) {
        // Vertical gradient bar for depth
        const grad = strobeCtx.createLinearGradient(0, 0, 0, h);
        grad.addColorStop(0, `rgba(${rgb.r},${rgb.g},${rgb.b},0.1)`);
        grad.addColorStop(0.3, `rgba(${rgb.r},${rgb.g},${rgb.b},0.7)`);
        grad.addColorStop(0.5, `rgba(${rgb.r},${rgb.g},${rgb.b},0.9)`);
        grad.addColorStop(0.7, `rgba(${rgb.r},${rgb.g},${rgb.b},0.7)`);
        grad.addColorStop(1, `rgba(${rgb.r},${rgb.g},${rgb.b},0.1)`);
        strobeCtx.fillStyle = grad;
        strobeCtx.beginPath();
        strobeCtx.roundRect(x, 4, barWidth, h - 8, 3);
        strobeCtx.fill();
      }

      // Center line indicator
      strobeCtx.strokeStyle = 'rgba(232, 228, 220, 0.15)';
      strobeCtx.lineWidth = 1;
      strobeCtx.setLineDash([4, 4]);
      strobeCtx.beginPath();
      strobeCtx.moveTo(w / 2, 0);
      strobeCtx.lineTo(w / 2, h);
      strobeCtx.stroke();
      strobeCtx.setLineDash([]);
    }

    function setMeterMode(mode) {
      meterMode = mode;
      localStorage.setItem('meterMode', mode);
      meterEl.classList.toggle('strobe-mode', mode === 'strobe');
      document.getElementById('modeToggle').classList.toggle('strobe-active', mode === 'strobe');
      if (mode === 'strobe') {
        resizeStrobe();
      }
    }

    // Event listeners
    startBtn.addEventListener('click', startListening);

    stringsEl.addEventListener('click', (e) => {
      const btn = e.target.closest('.string-btn');
      if (!btn) return;

      // Remove active from all
      document.querySelectorAll('.string-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');

      // Play reference tone
      const freq = parseFloat(btn.dataset.freq);
      playReferenceTone(freq);
    });

    tuningSelector.addEventListener('click', openTuningModal);
    closeTuningModal.addEventListener('click', closeTuningModalFn);
    tuningModal.addEventListener('click', (e) => {
      if (e.target === tuningModal) closeTuningModalFn();
    });

    tuningList.addEventListener('click', (e) => {
      const option = e.target.closest('.tuning-option');
      if (option) {
        selectTuning(option.dataset.tuning);
      }
    });

    // Mode toggle (needle/strobe)
    document.getElementById('modeToggle').addEventListener('click', () => {
      setMeterMode(meterMode === 'needle' ? 'strobe' : 'needle');
    });

    // Sound toggle
    const soundToggle = document.getElementById('soundToggle');

    function updateSoundToggle() {
      soundToggle.classList.toggle('enabled', pingEnabled);
      soundToggle.title = pingEnabled ? 'Sound on' : 'Sound off';
    }

    soundToggle.addEventListener('click', () => {
      pingEnabled = !pingEnabled;
      localStorage.setItem('pingEnabled', pingEnabled);
      updateSoundToggle();
    });

    updateSoundToggle();

    // Load saved tuning preference
    const savedTuning = localStorage.getItem('selectedTuning');
    if (savedTuning) {
      selectTuning(savedTuning);
    } else {
      renderStrings();
      renderTuningList();
    }

    // Initialize strobe
    initStrobe();
    setMeterMode(meterMode);
    window.addEventListener('resize', resizeStrobe);

    // === View switching ===
    function switchView(view) {
      currentView = view;
      document.getElementById('tunerViewWrapper').classList.toggle('hidden', view !== 'tuner');
      document.getElementById('metronomeContainer').classList.toggle('active', view === 'metronome');
      document.getElementById('recorderContainer').classList.toggle('active', view === 'recorder');
      document.getElementById('startContainer').style.display = view === 'tuner' ? '' : 'none';
      document.querySelectorAll('.tab-bar-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.view === view);
      });
      if (view === 'recorder' && !bpModuleLoaded) loadBasicPitch();
    }

    document.querySelectorAll('.tab-bar-btn').forEach(btn => {
      btn.addEventListener('click', () => switchView(btn.dataset.view));
    });

    // === Metronome ===
    function ensureAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioContext;
    }

    function renderBeatIndicators() {
      const container = document.getElementById('beatIndicators');
      container.innerHTML = '';
      for (let i = 0; i < metronomeBeats; i++) {
        const dot = document.createElement('div');
        dot.className = 'beat-dot' + (i === 0 ? ' accent' : '');
        container.appendChild(dot);
      }
    }

    function updateBeatIndicator(beat) {
      const dots = document.querySelectorAll('.beat-dot');
      dots.forEach((dot, i) => {
        dot.classList.toggle('active', i === beat);
      });
    }

    function scheduleNote(beat, time) {
      const ctx = ensureAudioContext();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();

      osc.type = 'triangle';
      osc.frequency.value = beat === 0 ? 1200 : 800;
      gain.gain.setValueAtTime(0.4, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);

      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start(time);
      osc.stop(time + 0.05);

      // Schedule visual update
      const delay = (time - ctx.currentTime) * 1000;
      setTimeout(() => updateBeatIndicator(beat), Math.max(0, delay));
    }

    function metronomeScheduler() {
      const ctx = ensureAudioContext();
      while (nextNoteTime < ctx.currentTime + SCHEDULE_AHEAD) {
        scheduleNote(metronomeCurrentBeat, nextNoteTime);
        nextNoteTime += 60 / metronomeBpm;
        metronomeCurrentBeat = (metronomeCurrentBeat + 1) % metronomeBeats;
      }
      metronomeTimerId = setTimeout(metronomeScheduler, LOOKAHEAD);
    }

    function startMetronome() {
      const ctx = ensureAudioContext();
      metronomePlaying = true;
      metronomeCurrentBeat = 0;
      nextNoteTime = ctx.currentTime;
      document.getElementById('metronomePlay').classList.add('playing');
      document.getElementById('playIcon').innerHTML = '<rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>';
      metronomeScheduler();
    }

    function stopMetronome() {
      metronomePlaying = false;
      clearTimeout(metronomeTimerId);
      metronomeTimerId = null;
      document.getElementById('metronomePlay').classList.remove('playing');
      document.getElementById('playIcon').innerHTML = '<path d="M8 5v14l11-7z"/>';
      document.querySelectorAll('.beat-dot').forEach(d => d.classList.remove('active'));
    }

    function setBpm(bpm) {
      metronomeBpm = Math.max(30, Math.min(300, bpm));
      document.getElementById('bpmValue').textContent = metronomeBpm;
      localStorage.setItem('metronomeBpm', metronomeBpm);
    }

    function setTimeSig(beats) {
      metronomeBeats = beats;
      localStorage.setItem('metronomeBeats', beats);
      document.querySelectorAll('.time-sig-btn').forEach(btn => {
        btn.classList.toggle('active', parseInt(btn.dataset.beats) === beats);
      });
      renderBeatIndicators();
      if (metronomePlaying) {
        stopMetronome();
        startMetronome();
      }
    }

    // Metronome event listeners
    document.getElementById('metronomePlay').addEventListener('click', () => {
      metronomePlaying ? stopMetronome() : startMetronome();
    });

    document.getElementById('bpmUp').addEventListener('click', () => setBpm(metronomeBpm + 1));
    document.getElementById('bpmDown').addEventListener('click', () => setBpm(metronomeBpm - 1));

    // Long press for fast BPM change
    ['bpmUp', 'bpmDown'].forEach(id => {
      let interval;
      const btn = document.getElementById(id);
      const delta = id === 'bpmUp' ? 1 : -1;
      btn.addEventListener('pointerdown', () => {
        interval = setInterval(() => setBpm(metronomeBpm + delta), 100);
      });
      btn.addEventListener('pointerup', () => clearInterval(interval));
      btn.addEventListener('pointerleave', () => clearInterval(interval));
    });

    document.getElementById('tapTempo').addEventListener('click', () => {
      const now = Date.now();
      // Reset if gap is too long
      if (tapTimes.length >= 1 && now - tapTimes[tapTimes.length - 1] > 3000) {
        tapTimes = [];
      }
      tapTimes.push(now);
      // Keep last 5 taps
      if (tapTimes.length > 5) tapTimes.shift();
      if (tapTimes.length >= 2) {
        const intervals = [];
        for (let i = 1; i < tapTimes.length; i++) {
          intervals.push(tapTimes[i] - tapTimes[i - 1]);
        }
        const avgInterval = intervals.reduce((a, b) => a + b) / intervals.length;
        setBpm(Math.round(60000 / avgInterval));
      }
    });

    document.getElementById('timeSigSelector').addEventListener('click', (e) => {
      const btn = e.target.closest('.time-sig-btn');
      if (btn) setTimeSig(parseInt(btn.dataset.beats));
    });

    // Initialize metronome
    setBpm(metronomeBpm);
    setTimeSig(metronomeBeats);

    // === Custom Tunings ===
    const CUSTOM_NOTES = ['C', 'C♯', 'D', 'D♯', 'E', 'F', 'F♯', 'G', 'G♯', 'A', 'A♯', 'B'];
    let customTunings = JSON.parse(localStorage.getItem('customTunings') || '[]');
    let customStringCount = 6;

    function noteToFreq(note, octave) {
      const noteIdx = CUSTOM_NOTES.indexOf(note);
      const midi = (octave + 1) * 12 + noteIdx;
      return A4 * Math.pow(2, (midi - 69) / 12);
    }

    function renderCustomStringRows() {
      const container = document.getElementById('customStringRows');
      container.innerHTML = '';
      for (let i = 0; i < customStringCount; i++) {
        const row = document.createElement('div');
        row.className = 'custom-string-row';

        const label = document.createElement('span');
        label.textContent = customStringCount - i;

        const noteSelect = document.createElement('select');
        noteSelect.dataset.idx = i;
        noteSelect.className = 'custom-note-select';
        CUSTOM_NOTES.forEach(n => {
          const opt = document.createElement('option');
          opt.value = n;
          opt.textContent = n;
          // Default to standard tuning notes
          const defaults = ['E', 'A', 'D', 'G', 'B', 'E'];
          if (i < defaults.length && n === defaults[i]) opt.selected = true;
          noteSelect.appendChild(opt);
        });

        const octSelect = document.createElement('select');
        octSelect.dataset.idx = i;
        octSelect.className = 'custom-oct-select';
        for (let o = 1; o <= 6; o++) {
          const opt = document.createElement('option');
          opt.value = o;
          opt.textContent = o;
          const defaultOcts = [2, 2, 3, 3, 3, 4];
          if (i < defaultOcts.length && o === defaultOcts[i]) opt.selected = true;
          octSelect.appendChild(opt);
        }

        row.appendChild(label);
        row.appendChild(noteSelect);
        row.appendChild(octSelect);
        container.appendChild(row);
      }
    }

    function renderCustomStringCount() {
      const container = document.getElementById('customStringCount');
      container.innerHTML = '';
      [4, 5, 6, 7].forEach(n => {
        const btn = document.createElement('button');
        btn.className = 'custom-string-count-btn' + (n === customStringCount ? ' active' : '');
        btn.textContent = n;
        btn.addEventListener('click', () => {
          customStringCount = n;
          renderCustomStringCount();
          renderCustomStringRows();
        });
        container.appendChild(btn);
      });
    }

    function saveCustomTuning() {
      const name = document.getElementById('customTuningName').value.trim();
      if (!name) return;

      const notes = [];
      const freqs = [];
      const noteSelects = document.querySelectorAll('.custom-note-select');
      const octSelects = document.querySelectorAll('.custom-oct-select');

      for (let i = 0; i < customStringCount; i++) {
        const note = noteSelects[i].value;
        const oct = parseInt(octSelects[i].value);
        notes.push(note + oct);
        freqs.push(Math.round(noteToFreq(note, oct) * 100) / 100);
      }

      const tuning = { name, notes, freqs, custom: true };

      // Replace if same name exists
      const existingIdx = customTunings.findIndex(t => t.name === name);
      if (existingIdx >= 0) {
        customTunings[existingIdx] = tuning;
      } else {
        customTunings.push(tuning);
      }

      localStorage.setItem('customTunings', JSON.stringify(customTunings));
      renderTuningList();
      closeCustomTuningForm();
      selectTuning(name);
    }

    function deleteCustomTuning(name) {
      customTunings = customTunings.filter(t => t.name !== name);
      localStorage.setItem('customTunings', JSON.stringify(customTunings));
      if (currentTuning.name === name) {
        selectTuning('Standard');
      }
      renderTuningList();
    }

    function openCustomTuningForm() {
      document.getElementById('customTuningForm').classList.add('open');
      document.getElementById('addCustomTuningBtn').style.display = 'none';
      document.getElementById('customTuningName').value = '';
      renderCustomStringCount();
      renderCustomStringRows();
    }

    function closeCustomTuningForm() {
      document.getElementById('customTuningForm').classList.remove('open');
      document.getElementById('addCustomTuningBtn').style.display = '';
    }

    document.getElementById('addCustomTuningBtn').addEventListener('click', openCustomTuningForm);
    document.getElementById('customTuningSave').addEventListener('click', saveCustomTuning);
    document.getElementById('customTuningCancel').addEventListener('click', closeCustomTuningForm);

    // Override renderTuningList to include custom tunings
    const _origRenderTuningList = renderTuningList;
    renderTuningList = function() {
      let html = '';

      // Custom tunings first if any exist
      if (customTunings.length > 0) {
        html += '<div class="tuning-category"><span class="tuning-category-label">Custom</span></div>';
        html += customTunings.map(tuning => `
          <button class="tuning-option ${tuning.name === currentTuning.name ? 'active' : ''}" data-tuning="${tuning.name}">
            <span class="tuning-option-name">${tuning.name}</span>
            <span class="tuning-option-notes">${tuning.notes.map(n => n.replace(/[0-9]/g, '')).join(' ')}</span>
          </button>
        `).join('');
      }

      // Built-in tunings
      html += Object.entries(TUNINGS).map(([category, tunings]) => `
        <div class="tuning-category">
          <span class="tuning-category-label">${category}</span>
        </div>
        ${tunings.map(tuning => `
          <button class="tuning-option ${tuning.name === currentTuning.name ? 'active' : ''}" data-tuning="${tuning.name}">
            <span class="tuning-option-name">${tuning.name}</span>
            <span class="tuning-option-notes">${tuning.notes.map(n => n.replace(/[0-9]/g, '')).join(' ')}</span>
          </button>
        `).join('')}
      `).join('');

      tuningList.innerHTML = html;

      // Add delete buttons to custom tunings
      customTunings.forEach(tuning => {
        const option = tuningList.querySelector(`[data-tuning="${tuning.name}"]`);
        if (option) {
          const delBtn = document.createElement('button');
          delBtn.className = 'delete-tuning-btn';
          delBtn.innerHTML = '&times;';
          delBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            deleteCustomTuning(tuning.name);
          });
          option.appendChild(delBtn);
        }
      });
    };

    // Override selectTuning to also check custom tunings
    const _origSelectTuning = selectTuning;
    selectTuning = function(tuningName) {
      // Check custom tunings first
      const customFound = customTunings.find(t => t.name === tuningName);
      if (customFound) {
        currentTuning = customFound;
        currentTuningName.textContent = currentTuning.name;
        renderStrings();
        renderTuningList();
        closeTuningModalFn();
        localStorage.setItem('selectedTuning', currentTuning.name);
        return;
      }
      _origSelectTuning(tuningName);
    };

    // Re-render to include custom tunings
    renderTuningList();

    // === Tab Recorder ===
    let isRecording = false;
    let mediaRecorder = null;
    let recordedChunks = [];
    let recordingStartTime = 0;
    let recordingTimer = null;
    let basicPitchModel = null;
    let bpModuleLoaded = false;
    let bpModule = null;
    let recordedEvents = [];

    const BP_MODEL_URL = 'model/model.json';
    const MIDI_TO_FREQ = (midi) => 440 * Math.pow(2, (midi - 69) / 12);

    // String tuning in MIDI note numbers for mapping
    function getTuningMidi() {
      return currentTuning.freqs.map(f => Math.round(12 * Math.log2(f / 440) + 69));
    }

    function showRecorderStatus(text, className) {
      const el = document.getElementById('recorderStatus');
      el.textContent = text;
      el.className = 'recorder-status-text';
      if (className) el.classList.add(className);
      // Add dot for recording
      if (className === 'recording') {
        el.innerHTML = '<span class="rec-dot"></span>' + text;
      }
      // Add spinner for processing
      if (className === 'processing') {
        el.innerHTML = '<span class="spinner"></span>' + text;
      }
    }

    async function loadBasicPitch() {
      if (bpModuleLoaded) return;
      showRecorderStatus('Loading ML model...', 'processing');
      try {
        const tf = await import('https://esm.sh/@tensorflow/tfjs@3');
        bpModule = await import('https://esm.sh/@spotify/basic-pitch');
        basicPitchModel = new bpModule.BasicPitch(BP_MODEL_URL);
        bpModuleLoaded = true;
        showRecorderStatus('Ready to record');
      } catch (err) {
        console.error('Failed to load BasicPitch:', err);
        showRecorderStatus('Model load failed — check connection');
      }
    }

    function updateRecorderTimer() {
      const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
      const mins = Math.floor(elapsed / 60);
      const secs = elapsed % 60;
      const timerEl = document.getElementById('recorderTimer');
      timerEl.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    async function startRecording() {
      if (isRecording) return;

      // Ensure model is loaded
      if (!bpModuleLoaded) {
        await loadBasicPitch();
        if (!bpModuleLoaded) return;
      }

      // Get microphone stream — reuse if tuner already has one
      let recStream = mediaStream;
      if (!recStream) {
        try {
          recStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        } catch (err) {
          console.error('Microphone access denied:', err);
          showRecorderStatus('Microphone access required');
          return;
        }
      }

      recordedChunks = [];
      mediaRecorder = new MediaRecorder(recStream, {
        mimeType: MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
          ? 'audio/webm;codecs=opus'
          : 'audio/webm'
      });

      mediaRecorder.ondataavailable = (e) => {
        if (e.data.size > 0) recordedChunks.push(e.data);
      };

      mediaRecorder.onstop = () => processRecording();

      mediaRecorder.start(250); // collect in 250ms chunks
      isRecording = true;
      recordingStartTime = Date.now();
      recordingTimer = setInterval(updateRecorderTimer, 200);

      // Update UI
      document.getElementById('recBtn').classList.add('recording');
      document.getElementById('recorderTimer').classList.add('recording');
      document.getElementById('recClearBtn').disabled = true;
      showRecorderStatus('Recording', 'recording');
    }

    function stopRecording() {
      if (!isRecording || !mediaRecorder) return;
      mediaRecorder.stop();
      isRecording = false;
      clearInterval(recordingTimer);

      document.getElementById('recBtn').classList.remove('recording');
      document.getElementById('recorderTimer').classList.remove('recording');
      showRecorderStatus('Processing audio...', 'processing');
    }

    function updateProgressBar(pct) {
      const bar = document.getElementById('recorderProgress');
      const fill = document.getElementById('recorderProgressFill');
      bar.classList.add('active');
      fill.style.width = (pct * 100) + '%';
    }

    async function processRecording() {
      if (recordedChunks.length === 0) {
        showRecorderStatus('No audio recorded');
        return;
      }

      const blob = new Blob(recordedChunks, { type: 'audio/webm' });
      const arrayBuf = await blob.arrayBuffer();

      // Ensure we have an audio context
      const ctx = audioContext || new (window.AudioContext || window.webkitAudioContext)();
      if (!audioContext) audioContext = ctx;

      let audioBuf;
      try {
        audioBuf = await ctx.decodeAudioData(arrayBuf);
      } catch (err) {
        console.error('Failed to decode audio:', err);
        showRecorderStatus('Failed to decode audio');
        document.getElementById('recorderProgress').classList.remove('active');
        return;
      }

      // Resample to 22050 Hz mono
      const targetSR = 22050;
      const numSamples = Math.ceil(audioBuf.duration * targetSR);
      const offCtx = new OfflineAudioContext(1, numSamples, targetSR);
      const src = offCtx.createBufferSource();
      src.buffer = audioBuf;
      src.connect(offCtx.destination);
      src.start();
      const resampled = await offCtx.startRendering();

      // Run BasicPitch
      let frames, onsets, contours;
      try {
        await basicPitchModel.evaluateModel(
          resampled,
          (f, o, c) => { frames = f; onsets = o; contours = c; },
          (pct) => updateProgressBar(pct)
        );
      } catch (err) {
        console.error('BasicPitch inference failed:', err);
        showRecorderStatus('Processing failed');
        document.getElementById('recorderProgress').classList.remove('active');
        return;
      }

      // Convert to note events
      // onsetThresh=0.25, frameThresh=0.15, minNoteLen=3 — tuned for guitar sensitivity
      // maxFreq=1400Hz (fret 24 high E), minFreq=70Hz (below low E=82Hz)
      const noteEvents = bpModule.noteFramesToTime(
        bpModule.addPitchBendsToNoteEvents(
          contours,
          bpModule.outputToNotesPoly(frames, onsets, 0.25, 0.15, 3, true, 1400, 70)
        )
      );

      // Filter to guitar range (MIDI 38~D2 to MIDI 90~F#6)
      const guitarNotes = noteEvents.filter(n => n.pitchMidi >= 38 && n.pitchMidi <= 90);

      // Debug: log raw BasicPitch output
      console.log('[tab] Raw BasicPitch notes:', guitarNotes.map(n => ({
        midi: n.pitchMidi,
        note: NOTES[n.pitchMidi % 12] + Math.floor(n.pitchMidi / 12 - 1),
        start: n.startTimeSeconds.toFixed(3),
        dur: n.durationSeconds.toFixed(3),
        amp: n.amplitude?.toFixed(3)
      })));

      processNoteEvents(guitarNotes);
      renderTab();

      document.getElementById('recorderProgress').classList.remove('active');
      document.getElementById('recorderProgressFill').style.width = '0%';
      document.getElementById('recClearBtn').disabled = false;

      if (recordedEvents.length > 0) {
        showRecorderStatus(`${recordedEvents.length} events detected`, 'ready');
      } else {
        showRecorderStatus('No notes detected — try playing louder');
      }
    }

    // Hand position tracker — smoothly follows where you're playing
    let handPosition = 0; // 0 = open/nut area

    // Common open chord shapes: [string0(low E), string1(A), ..., string5(high e)]
    // null = not played, 0 = open, N = fret
    const CHORD_SHAPES = [
      { name: 'C',  shape: [null, 3, 2, 0, 1, 0] },
      { name: 'G',  shape: [3, 2, 0, 0, 0, 3] },
      { name: 'G2', shape: [3, 2, 0, 0, 3, 3] },
      { name: 'D',  shape: [null, null, 0, 2, 3, 2] },
      { name: 'E',  shape: [0, 2, 2, 1, 0, 0] },
      { name: 'Em', shape: [0, 2, 2, 0, 0, 0] },
      { name: 'A',  shape: [null, 0, 2, 2, 2, 0] },
      { name: 'Am', shape: [null, 0, 2, 2, 1, 0] },
      { name: 'Dm', shape: [null, null, 0, 2, 3, 1] },
      { name: 'F',  shape: [null, null, 3, 2, 1, 1] },
      { name: 'B7', shape: [null, 2, 1, 2, 0, 2] },
      { name: 'G7', shape: [3, 2, 0, 0, 0, 1] },
      { name: 'C7', shape: [null, 3, 2, 3, 1, 0] },
      { name: 'D7', shape: [null, null, 0, 2, 1, 2] },
      { name: 'A7', shape: [null, 0, 2, 0, 2, 0] },
      { name: 'E7', shape: [0, 2, 0, 1, 0, 0] },
    ];

    // Try to match a set of MIDI notes against known chord shapes.
    // When a match is found, returns the FULL chord shape (chord completion) —
    // if BasicPitch only detected 3 of 5 notes in a C chord, we output all 5.
    function matchChordShape(midiNotes) {
      const tuningMidi = getTuningMidi();
      let bestMatch = null;
      let bestName = '';
      let bestScore = -1;
      let bestUnmatched = Infinity; // how many input notes didn't fit

      function tryShape(shapeAssignment, name) {
        // Count how many input notes match this shape
        let matched = 0;
        let unmatched = 0;
        const usedAssignments = new Set();
        for (const inputMidi of midiNotes) {
          const matchIdx = shapeAssignment.findIndex((a, i) => a.midi === inputMidi && !usedAssignments.has(i));
          if (matchIdx >= 0) {
            matched++;
            usedAssignments.add(matchIdx);
          } else {
            unmatched++;
          }
        }

        // Need: at least 2 notes matched, and no more than 1 spurious note
        if (matched < 2 || unmatched > 1) return;

        // Score: matched notes, penalize unmatched
        const score = matched * 10 - unmatched * 5;
        if (score > bestScore || (score === bestScore && unmatched < bestUnmatched)) {
          bestScore = score;
          bestUnmatched = unmatched;
          bestName = name;
          // Return the FULL chord shape — this is chord completion
          bestMatch = shapeAssignment.map(a => ({...a}));
        }
      }

      // Try all open chord shapes
      for (const chord of CHORD_SHAPES) {
        const shapeAssignment = [];
        for (let s = 0; s < tuningMidi.length; s++) {
          if (chord.shape[s] !== null) {
            shapeAssignment.push({
              string: s,
              fret: chord.shape[s],
              midi: tuningMidi[s] + chord.shape[s]
            });
          }
        }
        tryShape(shapeAssignment, chord.name);
      }

      // Also try barre chord shapes at every fret position
      const barreShapes = [
        { name: 'maj(E)', base: [0, 2, 2, 1, 0, 0] },
        { name: 'min(E)', base: [0, 2, 2, 0, 0, 0] },
        { name: 'maj(A)', base: [null, 0, 2, 2, 2, 0] },
        { name: 'min(A)', base: [null, 0, 2, 2, 1, 0] },
      ];

      for (const { name, base } of barreShapes) {
        for (let barre = 1; barre <= 12; barre++) {
          const shapeAssignment = [];
          for (let s = 0; s < tuningMidi.length; s++) {
            if (base[s] !== null) {
              const fret = base[s] + barre;
              if (fret > 24) continue;
              shapeAssignment.push({ string: s, fret, midi: tuningMidi[s] + fret });
            }
          }
          tryShape(shapeAssignment, `${name}@${barre}`);
        }
      }

      if (bestMatch) {
        console.log(`[tab] Chord matched: ${bestName} (${bestScore} score, ${bestUnmatched} unmatched)`);
      }
      return bestMatch;
    }

    // Score a complete string/fret assignment for a chord
    function scoreAssignment(assignment) {
      if (assignment.length === 0) return -Infinity;
      let score = 0;

      const frettedNotes = assignment.filter(a => a.fret > 0);
      const openNotes = assignment.filter(a => a.fret === 0);

      // Bonus for open strings (very common on guitar)
      score += openNotes.length * 4;

      // Prefer lower frets
      for (const a of assignment) {
        score -= a.fret * 0.4;
      }

      // Fret span penalty — tighter grouping is better
      if (frettedNotes.length >= 2) {
        const frets = frettedNotes.map(a => a.fret);
        const span = Math.max(...frets) - Math.min(...frets);
        score -= span * 3;
        // Harsh penalty for physically impossible spans
        if (span > 4) score -= (span - 4) * 10;
      }

      // Position continuity — prefer staying near current hand position
      if (handPosition > 0 && frettedNotes.length > 0) {
        const avgFret = frettedNotes.reduce((s, a) => s + a.fret, 0) / frettedNotes.length;
        score -= Math.abs(avgFret - handPosition) * 0.8;
      }

      // Natural string ordering — lower pitches on lower-numbered strings
      let orderBonus = 0;
      for (let i = 0; i < assignment.length; i++) {
        for (let j = i + 1; j < assignment.length; j++) {
          if (assignment[i].midi < assignment[j].midi && assignment[i].string < assignment[j].string) {
            orderBonus += 2;
          } else if (assignment[i].midi > assignment[j].midi && assignment[i].string > assignment[j].string) {
            orderBonus += 2;
          } else if (assignment[i].midi !== assignment[j].midi && assignment[i].string !== assignment[j].string) {
            orderBonus -= 3; // Crossed strings = unnatural
          }
        }
      }
      score += orderBonus;

      return score;
    }

    // Map a group of simultaneous MIDI notes to string/fret assignments
    // Uses chord shape matching first, then backtracking search with fret span pruning
    function mapChordToStrings(midiNotes) {
      const tuningMidi = getTuningMidi();
      const numStrings = tuningMidi.length;

      // First, try matching a known chord shape — returns full chord (completion)
      const chordMatch = matchChordShape(midiNotes);
      if (chordMatch) {
        // Chord shape matched — use it (includes completed notes)
        return chordMatch;
      }

      // No chord match — fall back to backtracking search
      const options = midiNotes.map(midi => {
        const opts = [];
        for (let s = 0; s < numStrings; s++) {
          const fret = midi - tuningMidi[s];
          if (fret >= 0 && fret <= 24) {
            opts.push({ string: s, fret, midi });
          }
        }
        return opts;
      });

      let bestAssignment = null;
      let bestScore = -Infinity;

      function search(noteIdx, assignment, usedStrings) {
        if (noteIdx === options.length) {
          const score = scoreAssignment(assignment);
          if (score > bestScore) {
            bestScore = score;
            bestAssignment = assignment.map(a => ({...a}));
          }
          return;
        }

        if (options[noteIdx].length === 0) {
          search(noteIdx + 1, assignment, usedStrings);
          return;
        }

        for (const opt of options[noteIdx]) {
          if (usedStrings.has(opt.string)) continue;

          // Prune: check fret span constraint
          const frettedFrets = assignment
            .filter(a => a.fret > 0)
            .map(a => a.fret);
          if (opt.fret > 0) frettedFrets.push(opt.fret);

          if (frettedFrets.length >= 2) {
            const span = Math.max(...frettedFrets) - Math.min(...frettedFrets);
            if (span > 5) continue;
          }

          usedStrings.add(opt.string);
          assignment.push(opt);
          search(noteIdx + 1, assignment, usedStrings);
          assignment.pop();
          usedStrings.delete(opt.string);
        }
      }

      search(0, [], new Set());
      return bestAssignment || [];
    }

    function processNoteEvents(timedNotes) {
      if (timedNotes.length === 0) {
        recordedEvents = [];
        return;
      }

      // Sort by start time
      const sorted = [...timedNotes].sort((a, b) => a.startTimeSeconds - b.startTimeSeconds);

      // Group notes into chords — strum window of 80ms
      // (strums take ~50-80ms from lowest to highest string)
      const groups = [];
      let currentGroup = [sorted[0]];

      for (let i = 1; i < sorted.length; i++) {
        if (sorted[i].startTimeSeconds - currentGroup[0].startTimeSeconds < 0.08) {
          currentGroup.push(sorted[i]);
        } else {
          groups.push(currentGroup);
          currentGroup = [sorted[i]];
        }
      }
      groups.push(currentGroup);

      // Reset hand position for each new recording
      handPosition = 0;

      // Map each group using chord-aware assignment
      recordedEvents = groups.map(group => {
        const time = group[0].startTimeSeconds;
        const duration = Math.max(...group.map(n => n.durationSeconds));
        const midiNotes = [...new Set(group.map(n => n.pitchMidi))].sort((a, b) => a - b);

        const assignment = mapChordToStrings(midiNotes);

        // Update hand position based on what was played
        const fretted = assignment.filter(a => a.fret > 0);
        if (fretted.length > 0) {
          const avgFret = fretted.reduce((s, a) => s + a.fret, 0) / fretted.length;
          handPosition = handPosition === 0 ? avgFret : handPosition * 0.6 + avgFret * 0.4;
        }

        const notes = assignment.map(a => ({
          string: a.string,
          fret: a.fret,
          midi: a.midi
        }));

        return { time, duration, notes };
      }).filter(e => e.notes.length > 0);
    }

    function renderTab() {
      const numStrings = currentTuning.notes.length;
      const labels = currentTuning.notes.map(n => n.replace(/[0-9]/g, ''));

      if (recordedEvents.length === 0) {
        document.getElementById('tabOutput').classList.remove('active');
        return;
      }

      // Build tab lines — strings go from high (index numStrings-1) to low (index 0)
      // Display order: high string on top
      const maxLineWidth = 80;
      const lines = [];

      // Build string label column (right-padded to 3 chars)
      const labelWidth = 3;

      // Calculate columns: each event is a column, spacing proportional to time gaps
      const MIN_GAP = 1;
      const MAX_GAP = 6;

      // Build columns
      const columns = [];
      for (let i = 0; i < recordedEvents.length; i++) {
        const event = recordedEvents[i];

        // Calculate gap before this event
        let gap = MIN_GAP;
        if (i > 0) {
          const dt = event.time - recordedEvents[i - 1].time;
          gap = Math.max(MIN_GAP, Math.min(MAX_GAP, Math.round(dt * 4)));
        }

        // Determine column width (multi-digit frets need more space)
        const maxFretDigits = Math.max(1, ...event.notes.map(n => String(n.fret).length));

        columns.push({ event, gap, width: maxFretDigits });
      }

      // Render lines for each string (high to low display order)
      for (let displayRow = 0; displayRow < numStrings; displayRow++) {
        const stringIdx = numStrings - 1 - displayRow;
        let line = (labels[stringIdx] + '|').padStart(labelWidth + 1);

        for (const col of columns) {
          // Add dashes for gap
          line += '-'.repeat(col.gap);

          // Find note on this string
          const noteOnString = col.event.notes.find(n => n.string === stringIdx);
          if (noteOnString) {
            const fretStr = String(noteOnString.fret);
            line += fretStr;
            // Pad if other columns in this chord are wider
            line += '-'.repeat(Math.max(0, col.width - fretStr.length));
          } else {
            line += '-'.repeat(col.width);
          }
        }

        line += '-|';
        lines.push(line);
      }

      const tabText = lines.join('\n');
      document.getElementById('tabPre').textContent = tabText;
      document.getElementById('tabOutput').classList.add('active');
    }

    function clearRecording() {
      recordedEvents = [];
      recordedChunks = [];
      document.getElementById('recorderTimer').textContent = '0:00';
      document.getElementById('tabOutput').classList.remove('active');
      document.getElementById('recClearBtn').disabled = true;
      showRecorderStatus('Ready to record');
    }

    function copyTabToClipboard() {
      const text = document.getElementById('tabPre').textContent;
      if (!text) return;
      navigator.clipboard.writeText(text).then(() => {
        const toast = document.getElementById('copyToast');
        toast.classList.add('show');
        setTimeout(() => toast.classList.remove('show'), 1500);
      });
    }

    function saveTab() {
      const text = document.getElementById('tabPre').textContent;
      if (!text) return;

      const tabs = JSON.parse(localStorage.getItem('savedTabs') || '[]');
      const name = `Tab ${tabs.length + 1}`;
      tabs.push({
        name,
        tab: text,
        tuning: currentTuning.name,
        date: new Date().toISOString()
      });
      localStorage.setItem('savedTabs', JSON.stringify(tabs));
      renderSavedTabs();
      showRecorderStatus('Tab saved', 'ready');
    }

    function loadSavedTab(index) {
      const tabs = JSON.parse(localStorage.getItem('savedTabs') || '[]');
      if (index < 0 || index >= tabs.length) return;
      document.getElementById('tabPre').textContent = tabs[index].tab;
      document.getElementById('tabOutput').classList.add('active');
      showRecorderStatus(`Loaded: ${tabs[index].name}`);
    }

    function deleteSavedTab(index) {
      const tabs = JSON.parse(localStorage.getItem('savedTabs') || '[]');
      tabs.splice(index, 1);
      localStorage.setItem('savedTabs', JSON.stringify(tabs));
      renderSavedTabs();
    }

    function renderSavedTabs() {
      const tabs = JSON.parse(localStorage.getItem('savedTabs') || '[]');
      const container = document.getElementById('savedTabsList');
      const items = document.getElementById('savedTabsItems');
      container.classList.toggle('has-tabs', tabs.length > 0);

      items.innerHTML = tabs.map((t, i) => {
        const d = new Date(t.date);
        const dateStr = `${d.getMonth() + 1}/${d.getDate()} ${d.getHours()}:${d.getMinutes().toString().padStart(2, '0')}`;
        return `
          <div class="saved-tab-item" data-idx="${i}">
            <div>
              <span class="saved-tab-name">${t.name}</span>
              <span class="saved-tab-date">${t.tuning} &middot; ${dateStr}</span>
            </div>
            <button class="saved-tab-delete" data-delete="${i}">&times;</button>
          </div>
        `;
      }).join('');
    }

    // Recorder event listeners
    document.getElementById('recBtn').addEventListener('click', () => {
      if (isRecording) {
        stopRecording();
      } else {
        startRecording();
      }
    });

    document.getElementById('recClearBtn').addEventListener('click', clearRecording);
    document.getElementById('copyTabBtn').addEventListener('click', copyTabToClipboard);
    document.getElementById('saveTabBtn').addEventListener('click', saveTab);

    document.getElementById('savedTabsItems').addEventListener('click', (e) => {
      const delBtn = e.target.closest('[data-delete]');
      if (delBtn) {
        e.stopPropagation();
        deleteSavedTab(parseInt(delBtn.dataset.delete));
        return;
      }
      const item = e.target.closest('.saved-tab-item');
      if (item) {
        loadSavedTab(parseInt(item.dataset.idx));
      }
    });

    // Stop recording if tuning changes
    const _origSelectTuning2 = selectTuning;
    selectTuning = function(tuningName) {
      if (isRecording) stopRecording();
      _origSelectTuning2(tuningName);
    };

    // Initialize saved tabs
    renderSavedTabs();
  </script>
<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js');
  }

  // PWA install logic
  (() => {
    const isStandalone = window.matchMedia('(display-mode: standalone)').matches
      || navigator.standalone === true;
    if (isStandalone) return;

    const installBtn = document.getElementById('installBtn');
    const installModal = document.getElementById('installModal');
    const installSteps = document.getElementById('installSteps');
    const installModalClose = document.getElementById('installModalClose');
    let deferredPrompt = null;

    const isIos = /iPhone|iPad/.test(navigator.userAgent);
    const isSafari = isIos && /Safari/.test(navigator.userAgent) && !/CriOS|FxiOS|OPiOS|EdgiOS/.test(navigator.userAgent);

    // Android/Chrome desktop: capture the native install prompt
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      installBtn.classList.add('visible');
    });

    // iOS: show button with instructions
    if (isIos) {
      installBtn.classList.add('visible');
    }

    installBtn.addEventListener('click', () => {
      if (deferredPrompt) {
        // Android/desktop Chrome: trigger native install
        deferredPrompt.prompt();
        deferredPrompt.userChoice.then(() => {
          deferredPrompt = null;
          installBtn.classList.remove('visible');
        });
      } else if (isIos && !isSafari) {
        // Non-Safari iOS browser: tell user to open in Safari
        installSteps.innerHTML = `
          <div class="install-step">
            <span class="install-step-num">!</span>
            <span class="install-step-text">Installing on iPhone only works in <strong>Safari</strong>. It does not work in Chrome or other browsers.</span>
          </div>
          <div class="install-step">
            <span class="install-step-num">1</span>
            <span class="install-step-text">Copy this page's URL and open it in <strong>Safari</strong></span>
          </div>
          <div class="install-step">
            <span class="install-step-num">2</span>
            <span class="install-step-text">Then tap <strong>Install</strong> again from there</span>
          </div>
        `;
        installModal.classList.add('open');
      } else {
        // Safari: show Add to Home Screen instructions
        const shareIcon = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M16 5l-1.42 1.42-1.59-1.59V16h-1.98V4.83L9.42 6.42 8 5l4-4 4 4zm4 5v11c0 1.1-.9 2-2 2H6c-1.1 0-2-.9-2-2V10c0-1.1.9-2 2-2h3v2H6v11h12V10h-3V8h3c1.1 0 2 .9 2 2z"/></svg>';
        installSteps.innerHTML = `
          <div class="install-step">
            <span class="install-step-num">1</span>
            <span class="install-step-text">Tap the Share button ${shareIcon} at the bottom of Safari</span>
          </div>
          <div class="install-step">
            <span class="install-step-num">2</span>
            <span class="install-step-text">Scroll down and tap <strong>Add to Home Screen</strong></span>
          </div>
          <div class="install-step">
            <span class="install-step-num">3</span>
            <span class="install-step-text">Tap <strong>Add</strong> to install</span>
          </div>
        `;
        installModal.classList.add('open');
      }
    });

    installModalClose.addEventListener('click', () => {
      installModal.classList.remove('open');
    });

    installModal.addEventListener('click', (e) => {
      if (e.target === installModal) installModal.classList.remove('open');
    });

    // Hide button once installed
    window.addEventListener('appinstalled', () => {
      installBtn.classList.remove('visible');
    });
  })();
</script>
</body>
</html>
